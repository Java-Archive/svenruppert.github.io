<p>In meinem Blog über CDi und i18n (<a href="http://www.rapidpm.org/2013/06/cdi-commons-i18n.html" target="_blank">Artikel</a>) hatte ich einen PropertyRegistryService vorgestellt.</p> <p>Als Beispiel wurde der Producer für die Instanz eines SimpleDateFormat gezeigt. </p> <p><a href="http://lh3.ggpht.com/-uHPakGHkaOQ/UcrzhykV6lI/AAAAAAABSKM/U5BFjin6KH4/s1600-h/image%25255B3%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-nl3-2Ew87K8/UcrzihB3ncI/AAAAAAABSKU/f0Z4x6v8JGU/image_thumb%25255B1%25255D.png?imgmax=800" width="644" height="284"></a></p> <p>Nicht schön war die harte Kopplung der Implementierung des PropertyRegistryService. Per Annotation wurde</p> <p>die Implementierung deklariert. <strong>@CDIPropertyRegistryFileBased</strong> (im Blog noch @CDIFileBased)</p> <p>Immer wieder muss aber zur Laufzeit entschieden werden welche Implementierung verwendet werden soll/muss.</p> <p>Das kann verschiedene Gründe haben wie z.B. das derzeitige Lastverhalten, der angemeldete User und und und.</p> <p>Wie also die Endscheidung vornehmen? </p> <p>Zwei Dinge sind notwendig:</p> <p>1) Das Interface der implementierenden Klasse, in unserem Fall PropertyRegistryService</p> <p>2) und der Qualifier um den richtigen Producer zu selektieren.</p> <p><a href="http://lh6.ggpht.com/-h00St984Puw/UcrzjsYJWqI/AAAAAAABSKY/_tdGiHgBOtM/s1600-h/image%25255B10%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-qqqZ7bBXoYU/UcrzkSEbvAI/AAAAAAABSKk/uysM0o1UCdo/image_thumb%25255B6%25255D.png?imgmax=800" width="1028" height="436"></a></p> <p>&nbsp;</p> <p>Das Interface ist relativ leicht zu ermitteln. Mann kann es fest angeben, da man weiß das man genau dieses Interface benötigt.</p> <p>Wenn auch das dynamisch ermittelt werden muss, kann man hier ähnlich wie bei den MessageRessourcen vorgehen. Es wird ein Key übergeben, der an anderer Stelle auf ein Interface gemappt wird. Hier einfach simuliert durch die Methode </p> <p><strong>Class mapp2Class(final String key)</strong></p> <p>Spannender wird es bei der Auswahl der richtigen Qualifiers. Das ist der Kern der Implementierung.&nbsp; Simuliert wird es hier </p> <p>durch die Methode <strong>resolveContextImpl().</strong> Wie genau die Implementierung aussehen kann, hängt von der Umgebung ab und welche Parameter ausgewertet werden müssen.</p> <p>Die Implementierung hier erzeugt ein <strong>AnnotationLiteral&lt;CDIPropertyRegistryFileBased&gt;.</strong> Das ist wieder eine harte Kopplung, kann jedoch wieder durch einen Mappingmechanismus zur Laufzeit aufgelöst werden.&nbsp; Am einfachsten,&nbsp; in dem man eine Klasse dynamisch instanziiert, die von AnnotationLitaral erbt.</p> <p>z.B.</p> <p><a href="http://lh6.ggpht.com/-G1N0nxPr5Jw/UcrzlHIDuvI/AAAAAAABSKs/Los4mxtfuRs/s1600-h/image%25255B14%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-y0L-RO_BVbQ/Ucrzl2JaOdI/AAAAAAABSK0/H3f7eFzzq1Y/image_thumb%25255B8%25255D.png?imgmax=800" width="644" height="118"></a></p>  