<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:openSearch="http://a9.com/-/spec/opensearchrss/1.0/"
     xmlns:blogger="http://schemas.google.com/blogger/2008"
     xmlns:georss="http://www.georss.org/georss"
     xmlns:gd="http://schemas.google.com/g/2005"
     xmlns:thr="http://purl.org/syndication/thread/1.0" version="2.0">
    <channel>
        <atom:id>tag:blogger.com,1999:blog-1854391241036740623</atom:id>
        <lastBuildDate>Tue, 15 Apr 2014 08:41:10 +0000</lastBuildDate>
        <category>CDI</category>
        <category>CDICommons</category>
        <category>JavaFX</category>
        <category>Java</category>
        <category>Weld</category>
        <category>RapidPM</category>
        <category>Arquillian</category>
        <category>IntelliJ</category>
        <category>jUnit</category>
        <category>EV3</category>
        <category>IDEA</category>
        <category>JDK8</category>
        <category>Mindstorms</category>
        <category>Lego</category>
        <category>lejos</category>
        <category>JBoss</category>
        <category>0.5.0</category>
        <category>IoT</category>
        <category>TableView</category>
        <category>Vaadin</category>
        <category>sensor</category>
        <category>Mindsuite</category>
        <category>Reflection</category>
        <category>TinkerForge</category>
        <category>Wildfly</category>
        <category>components</category>
        <category>infrared</category>
        <category>0.6.0</category>
        <category>Callback</category>
        <category>Core Java</category>
        <category>EJB</category>
        <category>JAXenter.de</category>
        <category>Java8</category>
        <category>Streams</category>
        <category>TestFX</category>
        <category>Tools</category>
        <category>motors</category>
        <category>Adam Bien afterburner.fx</category>
        <category>Baum</category>
        <category>Baumstruktur</category>
        <category>Bug</category>
        <category>CI</category>
        <category>Client</category>
        <category>Color</category>
        <category>Concurrency</category>
        <category>D3</category>
        <category>Deadlock</category>
        <category>DefaultFieldFactory</category>
        <category>FilteredTableView</category>
        <category>GPU</category>
        <category>Hibernate</category>
        <category>Integer</category>
        <category>JAAS</category>
        <category>JNDI</category>
        <category>JPA</category>
        <category>JavaEE</category>
        <category>JavaScript</category>
        <category>Jetbrains</category>
        <category>Kotlin</category>
        <category>M1ndsuite</category>
        <category>M2M</category>
        <category>MVP</category>
        <category>Photos</category>
        <category>PropertyBinding</category>
        <category>Proxy</category>
        <category>Raspberry PI</category>
        <category>SPMT</category>
        <category>Security</category>
        <category>Set</category>
        <category>Tabelle</category>
        <category>TableFieldFactory</category>
        <category>TeamCity</category>
        <category>Transactions</category>
        <category>Validation</category>
        <category>WADL CDI JAXRS</category>
        <category>control</category>
        <category>dependency injection</category>
        <category>löschen</category>
        <category>relection</category>
        <category>remote</category>
        <category>remote control</category>
        <category>windows</category>
        <title>RapidPM</title>
        <description>speaking Java... because it is a great pleasure for me.</description>
        <link>http://www.rapidpm.org/search/label/JavaFX</link>
        <managingEditor>noreply@blogger.com (Sven Ruppert)</managingEditor>
        <generator>Blogger</generator>
        <openSearch:totalResults>25</openSearch:totalResults>
        <openSearch:startIndex>1</openSearch:startIndex>
        <openSearch:itemsPerPage>25</openSearch:itemsPerPage>
        <item>
            <guid isPermaLink="false">tag:blogger.com,1999:blog-1854391241036740623.post-4739657487647960461</guid>
            <pubDate>Sun, 13 Apr 2014 11:40:00 +0000</pubDate>
            <atom:updated>2014-04-13T13:42:32.139+02:00</atom:updated>
            <category domain="http://www.blogger.com/atom/ns#">Java8</category>
            <category domain="http://www.blogger.com/atom/ns#">JavaFX</category>
            <title>Java8 CompletableFuture for JavaFX and CDI Part II</title>
            <description>The last part was describing how you could reach the goal to make the order of some dependent
                method calls independent. Now we will see, how we could use this for the combination of CDI and JavaFX.
                &lt;br/&gt;If you want to have CDI managed Controllers inside your JavaFX application you have to deal
                with the two life cycles. The init from CDI and the init from JavaFX. If you are combining both
                technologies, you will have the problem that the order of the livecycle steps are not always in the same
                order. Depending from the technology that will start, the order of the init methods will change. For CDI
                it is the method with the annotation Postconstruct and for JavaFX the method initialize. &lt;br/&gt;Well,
                lets see what you could do.. &lt;br/&gt;For this example I will start with the FXMLoader. Check the
                Method setControllerFactory. You will see, that after the creation of the Controller instance the method
                initInstance() will be called. &lt;br /&gt;&lt;pre class=&quot;brush: java&quot;&gt; &lt;br /&gt;@Singleton&lt;br
                /&gt;public class FXMLLoaderSingleton {&lt;br /&gt;&lt;br /&gt; private @Inject @CDILogger Logger
                logger;&lt;br /&gt; private @Inject Instance&amp;lt;CDIJavaFxBaseController&amp;gt; instance;&lt;br /&gt;&lt;br
                /&gt; private final ClassLoader cachingClassLoader = new
                FXClassLoader(FXMLLoader.getDefaultClassLoader());&lt;br /&gt; private final Map&amp;lt;Class,
                FXMLLoader&amp;gt; class2LoaderMap = new HashMap&amp;lt;Class, FXMLLoader&amp;gt;();&lt;br /&gt;&lt;br /&gt;
                public FXMLLoader getFXMLLoader(Class clazz) {&lt;br /&gt; final Map&amp;lt;Class, FXMLLoader&amp;gt;
                loaderMap = class2LoaderMap;&lt;br /&gt; final String name = clazz.getName();&lt;br /&gt; if
                (loaderMap.containsKey(clazz)) {&lt;br /&gt; if (logger.isDebugEnabled()) {&lt;br /&gt; logger.debug(&amp;quot;fx
                loader fuer diese klasse schon in der map &amp;quot; + name);&lt;br /&gt; }&lt;br /&gt; } else {&lt;br /&gt;
                final String fxmlFileName = clazz.getSimpleName() + &amp;quot;.fxml&amp;quot;;&lt;br /&gt; if
                (logger.isDebugEnabled()) {&lt;br /&gt; logger.debug(&amp;quot;fxmlFileName -&amp;gt; &amp;quot; +
                fxmlFileName);&lt;br /&gt; }&lt;br /&gt; final URL resource = clazz.getResource(fxmlFileName);&lt;br /&gt;//
                FXMLLoader loader = new CDIFXMLLoader(resource);&lt;br /&gt; FXMLLoader loader = new
                FXMLLoader(resource);&lt;br /&gt; loader.setClassLoader(cachingClassLoader);&lt;br /&gt;
                loader.setControllerFactory(new Callback&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt;() {&lt;br /&gt;
                @Override&lt;br /&gt; public Object call(Class&amp;lt;?&amp;gt; param) {&lt;br /&gt; final Class&amp;lt;JavaFXBaseController&amp;gt;
                p = (Class&amp;lt;JavaFXBaseController&amp;gt;) param;&lt;br /&gt; final JavaFXBaseController controller
                = instance.select(p).get();&lt;br /&gt; &lt;b&gt;controller.initInstance(); //trigger async call&lt;/b&gt;&lt;br
                /&gt; return controller;&lt;br /&gt; }&lt;br /&gt; });&lt;br /&gt; try { &lt;br /&gt; final Class&amp;lt;?&amp;gt;
                aClass = Class.forName(clazz.getName() + &amp;quot;Controller&amp;quot;);&lt;br /&gt; final
                CDIJavaFxBaseController call = (CDIJavaFxBaseController) loader.getControllerFactory().call(aClass);&lt;br
                /&gt; loader.setController(call);&lt;br /&gt; } catch (ClassNotFoundException e) {&lt;br /&gt;
                logger.error(e);&lt;br /&gt; }&lt;br /&gt; loaderMap.put(clazz, loader);&lt;br /&gt; }&lt;br /&gt;
                return loaderMap.get(clazz);&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt; private FXMLLoaderSingleton() {&lt;br
                /&gt; }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br/&gt;The method &lt;b&gt;initInstance()&lt;/b&gt; will
                trigger the init-process. Inside the method the task will be called async. The task itself will wait
                until the CDi and JavaFX init will be ready. After this the method initBusinessLogic will be called.
                This means, thet the developer only will have to implement the method &lt;b&gt;initBusinessLogic&lt;/b&gt;
                and he will be sure that all init stuff is done. &lt;br/&gt;Happy coding ;-) &lt;br /&gt;&lt;pre class=&quot;brush:
                java&quot;&gt;&lt;br /&gt;public abstract class JavaFXBaseController implements CDIJavaFxBaseController
                {&lt;br /&gt;&lt;br /&gt; public static final String DONE = &quot;done&quot;;&lt;br /&gt;&lt;br /&gt;
                private boolean mockModusActive = false;&lt;br /&gt; public boolean isMockModusActive() {&lt;br /&gt;
                return mockModusActive;&lt;br /&gt; }&lt;br /&gt; public void setMockModusActive(boolean
                mockModusActive) {&lt;br /&gt; this.mockModusActive = mockModusActive;&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt;
                public abstract void cleanUp();&lt;br /&gt;&lt;br /&gt; public abstract void setI18n();&lt;br /&gt;&lt;br
                /&gt; private @Inject @CDILogger Logger logger;&lt;br /&gt;&lt;br /&gt; private Boolean initCompleteCDI
                = false;&lt;br /&gt; private Boolean initCompleteFX = false;&lt;br /&gt;&lt;br /&gt; public
                CompletableFuture&lt;String&gt; supplyAsync;&lt;br /&gt;&lt;br /&gt; @Override&lt;br /&gt; public final
                void initInstance(){&lt;br /&gt; final CachedThreadPoolSingleton instance =
                CachedThreadPoolSingleton.getInstance();&lt;br /&gt; supplyAsync = CompletableFuture.supplyAsync(task,
                instance.cachedThreadPool);&lt;br /&gt; if (logger.isDebugEnabled())
                supplyAsync.thenAccept(logger::debug); //logger&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt; public final
                Supplier&lt;String&gt; task = ()-&gt; {&lt;br /&gt;// Warten bis alle true&lt;br /&gt; while(!
                (initCompleteCDI &amp;&amp; initCompleteFX) ){&lt;br /&gt; try {&lt;br /&gt; //evtl loggen&lt;br /&gt;
                if (logger.isDebugEnabled()) {&lt;br /&gt; logger.debug(&quot;initCompleteCDI = &quot; +
                initCompleteCDI);&lt;br /&gt; logger.debug(&quot;initCompleteFX = &quot; + initCompleteFX);&lt;br /&gt;
                logger.debug(&quot;getClass().getName() = &quot; + getClass().getName());&lt;br /&gt; }&lt;br /&gt;
                TimeUnit.MILLISECONDS.sleep(1);&lt;br /&gt; } catch (InterruptedException e) {&lt;br /&gt;
                e.printStackTrace();&lt;br /&gt; return e.toString();&lt;br /&gt; }&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt;
                if (logger.isInfoEnabled()) {&lt;br /&gt; logger.info(&quot;initBusinessLogic() =&gt; called now&quot;);&lt;br
                /&gt; }&lt;br /&gt; final boolean fxApplicationThread = Platform.isFxApplicationThread();&lt;br /&gt; if
                ( ! fxApplicationThread){&lt;br /&gt; Platform.runLater(this::initBusinessLogic);&lt;br /&gt; } else {&lt;br
                /&gt; initBusinessLogic();&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; if (logger.isInfoEnabled())
                {&lt;br /&gt; logger.info(&quot;initBusinessLogic() =&gt; done now&quot;);&lt;br /&gt; }&lt;br /&gt;
                return DONE;&lt;br /&gt; };&lt;br /&gt;&lt;br /&gt; @PostConstruct&lt;br /&gt; public final void
                postconstruct(){&lt;br /&gt; if (logger.isDebugEnabled()) {&lt;br /&gt; logger.debug(&quot;PostConstruct
                mockModusActive == &quot; + mockModusActive);&lt;br /&gt; }&lt;br /&gt; cdiPostConstruct();&lt;br /&gt;
                initCompleteCDI = true;&lt;br /&gt; if (logger.isDebugEnabled()) {&lt;br /&gt; logger.debug(&quot;postconstruct
                ready &quot; + getClass().getName());&lt;br /&gt; }&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt; public
                abstract void cdiPostConstruct();&lt;br /&gt;&lt;br /&gt; @Override&lt;br /&gt; public final void
                initialize(URL url, ResourceBundle resourceBundle) {&lt;br /&gt; if (logger.isDebugEnabled()) {&lt;br /&gt;
                logger.debug(&quot;initialize mockModusActive== &quot; + mockModusActive);&lt;br /&gt; }&lt;br /&gt;
                initializeFX(url, resourceBundle);&lt;br /&gt; initCompleteFX = true;&lt;br /&gt; if
                (logger.isDebugEnabled()) {&lt;br /&gt; logger.debug(&quot;initialize ready &quot; +
                getClass().getName());&lt;br /&gt; }&lt;br /&gt; }&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; protected
                abstract void initializeFX(URL url, ResourceBundle resourceBundle);&lt;br /&gt; /**&lt;br /&gt; * wird
                nach der init von CDI und JavaFX aufgerufen,&lt;br /&gt; * egal in welcher Reihenfolge die init
                durchlaufen wird.&lt;br /&gt; *&lt;br /&gt; * ein blockierender method call&lt;br /&gt; *&lt;br /&gt; */&lt;br
                /&gt; public abstract void initBusinessLogic();&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;    </description>
            <link>http://www.rapidpm.org/2014/04/java8-completablefuture-for-javafx-and.html</link>
            <author>noreply@blogger.com (Sven Ruppert)</author>
            <thr:total>0</thr:total>
            <gd:extendedProperty name="commentSource" value="1"/>
            <gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/>
        </item>
        <item>
            <guid isPermaLink="false">tag:blogger.com,1999:blog-1854391241036740623.post-7739067418851390799</guid>
            <pubDate>Fri, 28 Mar 2014 12:28:00 +0000</pubDate>
            <atom:updated>2014-03-28T13:30:04.320+01:00</atom:updated>
            <category domain="http://www.blogger.com/atom/ns#">CDI</category>
            <category domain="http://www.blogger.com/atom/ns#">Concurrency</category>
            <category domain="http://www.blogger.com/atom/ns#">Core Java</category>
            <category domain="http://www.blogger.com/atom/ns#">Java8</category>
            <category domain="http://www.blogger.com/atom/ns#">JavaFX</category>
            <title>Java8 CompletableFuture for JavaFX and CDI Part I</title>
            <description>Java8 CompletableFuture for JavaFX and CDI Part I Java8 will give you a few more tools to solve
                concurrency problems.&lt;br/&gt;One of them is the CompletableFuture. I will show you, how you could
                sync the &lt;br/&gt;two different init-cycles from CDI and JavaFX with this.&lt;br/&gt;&lt;br/&gt;CDI
                and JavaFX are using a life-cycle during the init process. &lt;br/&gt;For CDI you can use the method
                that is annotated with the &lt;br/&gt;AnnotationLiteral @Postconstruct and for JavaFX you can use the
                method initialize(..) &lt;br/&gt;If you want to have a method that is called after both others are
                finished you have to think &lt;br/&gt;about the problem that it is not clear which method is called
                first.&lt;br/&gt;To show more in detail what the problem is let us think about the following. &lt;br /&gt;&lt;pre
                class=&quot;brush: java&quot;&gt; &lt;br /&gt;private String pattern;&lt;br /&gt;private
                SimpleDateFormat sdf;&lt;br /&gt;&lt;br /&gt;//beispielhaft für eine init&lt;br /&gt;public void
                createSDF(){&lt;br /&gt; this.sdf = new SimpleDateFormat(this.pattern); &lt;br /&gt;}&lt;br /&gt;&lt;br
                /&gt;//beispielhaft für eine init&lt;br /&gt;public void newPattern(final String pattern) {&lt;br /&gt;
                this.pattern = pattern;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;public String format(final Date date){&lt;br
                /&gt; return sdf.fomat(date);&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt; To use the method format(..) you must
                use the methods newPattern(..) and createSDF first.&lt;br/&gt;But both in the right order like the
                following code snipp. &lt;br /&gt;&lt;pre class=&quot;brush: java&quot;&gt; &lt;br /&gt;newPattern(&quot;yyyy.MM.dd&quot;);&lt;br
                /&gt;createSDF();&lt;br /&gt;final String s = versionAB.format(new Date());&lt;br /&gt;System.out.println(&quot;s
                = &quot; + s);&lt;br /&gt;&lt;/pre&gt;If you are calling first createSDF(..) for example you will get an
                exception.&lt;br/&gt;But thinking to the problem with CDI and JavaFX it must be valid to do something
                like the following. &lt;br /&gt;&lt;pre class=&quot;brush: java&quot;&gt; &lt;br /&gt;createSDF();&lt;br
                /&gt;newPattern(&quot;yyyy.MM.dd&quot;);&lt;br /&gt;&lt;br /&gt;final String s = versionAB.format(new
                Date());&lt;br /&gt;System.out.println(&quot;s = &quot; + s);&lt;br /&gt;&lt;/pre&gt;The method
                creatdSDF(..) is called before newPattern(..).&lt;br/&gt;The solution is quite simple. The method call
                from createSDF must be non blocking but&lt;br/&gt; waiting with the execution until newPattern(..) was
                called.&lt;br/&gt;The same with format(..). This method call must wait until both are finished but
                itself it &lt;br/&gt;is an blocking method call. This is to give the developer the feeling he expected,
                &lt;br/&gt;if he is working with the result from format(..). &lt;br/&gt;To solve this we have to
                booleans called initCompleteA and initCompleteB. &lt;br/&gt;Both are false in the beginning. If
                newPattern(..) is called initcompleteA will be true, &lt;br/&gt;and initCompleteB will be true after the
                method creatSDF() is ready. &lt;br /&gt;&lt;pre class=&quot;brush: java&quot;&gt; &lt;br /&gt;public
                void newPattern(final String pattern) {&lt;br /&gt; this.pattern = pattern;&lt;br /&gt;
                initCompleteA=true;&lt;br /&gt; System.out.println(&quot;newPattern = &quot; + pattern);&lt;br /&gt;}&lt;br
                /&gt;public void createSDF(){&lt;br /&gt; CompletableFuture&amp;lt;Void&amp;gt; supplyAsync&lt;br /&gt;
                = CompletableFuture&lt;br /&gt; .supplyAsync(taskCreateSDF, cachedThreadPool);&lt;br /&gt;
                supplyAsync.thenAccept(System.out::println);&lt;br /&gt;}&lt;br /&gt;public Supplier&amp;lt;Void&amp;gt;
                taskCreateSDF = ()-&amp;gt; {&lt;br /&gt; while(! initCompleteA ){&lt;br /&gt; try {&lt;br /&gt;
                System.out.println(&quot;createSDF is waiting&quot; );&lt;br /&gt; TimeUnit.MILLISECONDS.sleep(4);&lt;br
                /&gt; } catch (InterruptedException e) {&lt;br /&gt; e.printStackTrace();&lt;br /&gt; }&lt;br /&gt; }&lt;br
                /&gt; sdf = new SimpleDateFormat(pattern);&lt;br /&gt; initCompleteB = true;&lt;br /&gt; return null;&lt;br
                /&gt;};&lt;br /&gt;&lt;/pre&gt; The Method format(..) now is only waiting for both... &lt;br /&gt;&lt;pre
                class=&quot;brush: java&quot;&gt; &lt;br /&gt;public Supplier&amp;lt;String&amp;gt; task = ()-&amp;gt; {&lt;br
                /&gt;//Warten bis alle true&lt;br /&gt; while(! (initCompleteA &amp;&amp; initCompleteB) ){&lt;br /&gt;
                try {&lt;br /&gt; System.out.println(&quot;initCompleteA = &quot; + initCompleteA);&lt;br /&gt;
                System.out.println(&quot;initCompleteB = &quot; + initCompleteB);&lt;br /&gt; System.out.println(&quot;pattern
                = &quot; + pattern);&lt;br /&gt; System.out.println(&quot;sdf = &quot; + sdf);&lt;br /&gt;
                TimeUnit.MILLISECONDS.sleep(1);&lt;br /&gt; } catch (InterruptedException e) {&lt;br /&gt;
                e.printStackTrace();&lt;br /&gt; }&lt;br /&gt; }&lt;br /&gt; return sdf.format(this.date);&lt;br /&gt;};&lt;br
                /&gt;private Date date;&lt;br /&gt;&lt;br /&gt;public String format(final Date date){&lt;br /&gt;
                this.date = date;&lt;br /&gt; supplyAsync = CompletableFuture&lt;br /&gt; .supplyAsync(task,
                cachedThreadPool);&lt;br /&gt; try {&lt;br /&gt; return supplyAsync.get();&lt;br /&gt; } catch
                (InterruptedException | ExecutionException e) {&lt;br /&gt; e.printStackTrace();&lt;br /&gt; }&lt;br /&gt;
                return &quot;&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt; The example you will find at &lt;a href=&quot;http://stash.rapidpm.org/projects/PUB/repos/jaxenter.de-0016-async-calls/browse&quot;&gt;http://stash.rapidpm.org/projects/PUB/repos/jaxenter.de-0016-async-calls/browse&lt;/a&gt;&lt;br/&gt;The
                next Part will show how we have to implement the JavaFX CDI bootstrapping to use this.
            </description>
            <link>http://www.rapidpm.org/2014/03/java8-completablefuture-for-javafx-and.html</link>
            <author>noreply@blogger.com (Sven Ruppert)</author>
            <thr:total>0</thr:total>
            <gd:extendedProperty name="commentSource" value="1"/>
            <gd:extendedProperty name="commentModerationMode" value="FILTERED_POSTMOD"/>
        </item>

    </channel>
</rss>
