<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>JDK8</title>
    <category label="JDK8"/>
    <updated>2015-01-10T02:14:20.983+01:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <author>
        <name>Alexander Bischof</name>
    </author>
    <entry>
        <title>SpeedUp from Charts with Streams</title>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Streams"/>
        <published>2013-11-09T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2013/11/09/speedup-from-charts-with-streams.html" rel="tag"&gt;SpeedUp from Charts with Streams&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2013-11-09"&gt;2013-11-09&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;Today we I am writing about the possibillity to speedup the JavaFX GUI elements with the new streams-API from JDK8.
&lt;br /&gt;
Let´s play with the original example from Oracle. The LineChart demo will be used as base for the following.
We are collecting/generating values for a line of points for every hundreds step. Al steps between are interpolated with splines.
For calculating the splines I am using the jakarta-commons math3 lib.&lt;a href="http://commons.apache.org/proper/commons-math/"&gt; [1]&lt;/a&gt;&lt;br /&gt;
Normaly the following steps are needed to generate a LineChart.
- get the base values to show&lt;br /&gt;
- calculate the interpolated values&lt;br /&gt;
- create the line-elements&lt;br /&gt;
- fill the Line-Chart and show it&lt;br /&gt;
&lt;br /&gt;

&lt;b&gt;Get the base values to show&lt;/b&gt;&lt;br /&gt;

For this example we are generating the values we are needing. To hold the values for a List of curves
I am using a
&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
List&lt;List&lt;Integer&gt;&gt;
]]&gt;&lt;/script&gt;

Without streams you could do it like this:
&lt;br /&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public List&lt;List&lt;Integer&gt;&gt; generateDemoValueMatrix(){
final List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
   for (int i = 0; i&lt;200; i++){
   	final List&lt;Integer&gt; generatedDemoValuesForY = generateDemoValuesForY();
        	result.add(generatedDemoValuesForY);            
}
   	return result;
}

public List&lt;Integer&gt; generateDemoValuesForY(){
final Random random = new Random();
   final List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
   for(int i = 0; i&lt;10; i++){
   	result.add(random.nextInt(100));
   }
   return result;
}
]]&gt;&lt;/script&gt;

But with streams I could write this in a more compact form.
The nice here is the possibility to concat the single steps. But this is only to show the new streams api.
There is no parallel part.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
public List&lt;List&lt;Integer&gt;&gt; generateDemoValueMatrix(){
return Stream
   	.generate(this::generateDemoValuesForY)
         .limit(200)	//Anzahl Kurven
         .collect(Collectors.toList());
}

public List&lt;Integer&gt; generateDemoValuesForY(){
final Random random = new Random();
   return Stream
   	.generate(() -&gt; random.nextInt(100))
         .limit(10)
         .collect(Collectors.toList());
}
]]&gt;&lt;/script&gt;
&lt;b&gt; Calculate the interpolated values &lt;/b&gt;

Now I will start to caclculate the interpolated values. For this I am using the commons-math3 lib from Apache.
The way to do this is short and straid forward.
- Get the base values from the curve you want to calculate on &lt;br /&gt;
- Choose the algorithm you want to use&lt;br /&gt;
- Fill the base values as init into the function&lt;br /&gt;

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
private UnivariateFunction createInterpolateFunction(
final List&lt;Integer&gt; values){

   final double[] valueArrayX = new double[values.size()];
   for (int i = 0; i &lt; valueArrayX.length; i++) {
   	valueArrayX[i] = (double)i* STEP_SIZE;
  	}

   final double[] valueArrayY = new double[values.size()];
   int i=0;
   for (final Integer value : values) {
   	valueArrayY[i] = (double) value.intValue();
         i= i+1;
  	}

   final UnivariateInterpolator interpolator = 
new SplineInterpolator();
   final UnivariateFunction function = 
interpolator.interpolate(valueArrayX, valueArrayY);
  	return function;
}
]]&gt;&lt;/script&gt;

Now we are able to caculate the interpolated values.
This is something we can do in parallel for every curve. This means that we can start with the speed up.
The importand parts are the
".parallelStream()" to start a Thread for eveery elements of the List
and during the "map(v-&amp;gt; ... )" phase the calculation is done. Every task is put to the Root - Fork-And-Join Pool.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
private List&lt;List&lt;Double&gt;&gt; getValuesForSeries() {
final List&lt;List&lt;Integer&gt;&gt; demoValueMatrix =
generateDemoValueMatrix();
   final List&lt;List&lt;Double&gt;&gt; collect = demoValueMatrix
   	.parallelStream()
         	.map(v -&gt; {
         		final UnivariateFunction interpolateFunction = 
createInterpolateFunction(v);
              	//baue Kurve auf
                final int anzahlValuesInterpolated = 
(v.size()-1) * STEP_SIZE;
               	final List&lt;Double&gt; result = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; anzahlValuesInterpolated-1; i++) {
                	final double valueForY = 
interpolateFunction.value(i);
                     	result.add(valueForY);
              	}
                return result;
       	})
         .collect(Collectors.toList());
return collect;
}

]]&gt;&lt;/script&gt;
&lt;b&gt;Create the line-elements&lt;/b&gt;

The grafical elements for the Line-Chart are created in the same way. In parallel for every curve.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[

private List&lt;XYChart.Series&gt; generateNextSeries(){
final List&lt;XYChart.Series&gt; chartSeries = getValuesForSeries()
   	.parallelStream()
         	.map(v -&gt; {
        		final XYChart.Series nextSeries = new XYChart.Series();
               	int i = 0;
                for (final Double valueForY : v) {
                	final XYChart.Data data 
= new XYChart.Data(i, valueForY);
                  	nextSeries.getData().add(data);
                     	i = i + 1;
              	}
                return nextSeries;
        	}).collect(Collectors.toList());
   return chartSeries;
}
]]&gt;&lt;/script&gt;
&lt;b&gt; Fill the Line-Chart and show it&lt;/b&gt;

Now the last step is the filling of the Line-Chart itself.
This is done in a seriel way. No parralel way is possible in the moment.
But this is not the part that could bring a speed-up.

&lt;script class="brush: java" type="syntaxhighlighter"&gt;&lt;![CDATA[
final List&lt;XYChart.Series&gt; serieses = generateNextSeries();
final ObservableList&lt;XYChart.Series&gt; data = lineChart.getData();
data.addAll(serieses);
]]&gt;&lt;/script&gt;

&lt;b&gt; Lesson Learned&lt;/b&gt;


What we can see is the possibillity to speed up the GUI part in several ways.
Not only the generating of the values itself. The creation of the grafical elements could be done in parralel too.
The seriell Version LineChartSerialDemo, needed for the 11´th round 2.799.209.417ns and the parralel version
LineChartDemo was done in 261.545.220ns.
This is a speed up of 10 at my MacBookPro.

Happy coding..








&lt;!--10--&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;!--200--&gt;&lt;/list&gt;&lt;/list&gt;&lt;/pre&gt;&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2013-11-09&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FXController with CDI managed DynamicObjectAdapter - Part 1</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Reflection"/>
        <category label="Weld"/>
        <published>2014-01-10T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/01/10/fxcontroller-with-cdi-managed-dynamico.html" rel="tag"&gt;FXController with CDI managed DynamicObjectAdapter - Part 1&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-01-10"&gt;2014-01-10&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;Today I will show the first step how you can use a dynamic proxy for JavaFX Controller.&lt;br/&gt;
This we will need for the CDI support inside TestFX.. but this later..&lt;br/&gt;
&lt;br/&gt;
During I was writing on my reflection shortcut together with Dr. Heinz Kabutz&lt;br/&gt;
(will be first available in german, later in english if asked for) I was thinking about his Newsletter &lt;br/&gt;
about "Object Adapter based on Dynamic Proxy". &lt;br/&gt;
Based on this we will now transform this into an CDI pattern for JavaFX Controller.&lt;br/&gt;
&lt;br/&gt;
The basic target will be an decorator for an CDI environment, to switch between implementations of defined methods&lt;br/&gt;
of an controller. Ok, there is an decorator defined inside the CDI environment but with some hard limitations.&lt;br/&gt;
&lt;br/&gt;
First of all, you have to define the decorator inside the beans.xml. I don´t like this. &lt;br/&gt;
If something will be changed you have to restart the container. And the definition is static.&lt;br/&gt;
The second I not like, is the usage of an decorator. &lt;br/&gt;
&lt;br/&gt;
You have to annotate the class, &lt;br/&gt;
you have to inject the basic implementation&lt;br/&gt;
and you have to extend the basic implementation.  &lt;br/&gt;
&lt;br/&gt;
This is too much and the main disadvantage: you have to decide what decorator to use in the static context.&lt;br/&gt;
&lt;br/&gt;
How to solve this? &lt;br/&gt;
&lt;br/&gt;
Let´s start with the basic step. With the default methods in JDK8 you don´t need a basic Implementation class.&lt;br/&gt;
But you have an interface. Let´s say we have an interface called DemoLogic.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@CDINotMapped
public interface DemoLogic {

    public default int add(int a, int b){
        return a+b;
    }

    public default int sub(int a, int b){
        return a-b;
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Importand is the annotation, to exclude this from the default scope inside CDI. You will see it later why..&lt;br/&gt;
&lt;br/&gt;
The next thing we want to have is an special implementation from the add method. This we will implement inside a class &lt;br/&gt;
called DemoLogicAdapter_A.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@CDINotMapped
public class DemoLogicAdapter_A implements DemoLogic{

    public int add(int a, int b){
        System.out.println("DemoLogicAdapter_A.add");
        return a+b + 100;
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Same here with the annotation. The good thing is, you really have to implement the changed method only.&lt;br/&gt;
No other delegator stuff.&lt;br/&gt;
&lt;br/&gt;
Next we need, is something to decide dynamically if we want to use the original implementation or the special one.&lt;br/&gt;
This we will simulate with a singleton calles Context. This class with only one boolean attribute called original&lt;br/&gt;
is to simulate a decicion logic.&lt;br/&gt;
If the attribute is true, we are in context original otherwise we are inside the context customer specific.&lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Singleton
public class Context {

    public boolean original = true;
}
    &lt;/class&gt;&lt;/pre&gt;

Now we will use it like the developer will do it later in a high level way.&lt;br/&gt;
For this we write a jUnit Test to test this.&lt;br/&gt;
The test will do the following.&lt;br/&gt;
Inject the DemoLogic, call the method add and test if the original version was used.&lt;br/&gt;
After this switch the context by setting the attribut original to false.&lt;br/&gt;
Now get the demologic again and call the method add. &lt;br/&gt;
If all is all right we will get the customer specific result.&lt;br/&gt;


&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@RunWith(Arquillian.class)
public class DemoLogicTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
                .addPackages(true, "org.rapidpm.commons")
                .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
    }

    @Inject @DynamicDecoratorTest Instance&lt;DemoLogic&gt; demoLogic;
    @Inject Context context;
    @Test
    public void testDemoLogicOriginalTest() throws Exception {
    Assert.assertNotNull(demoLogic);
    final DemoLogic demoLogic1 = demoLogic.get();
    final int add = demoLogic1.add(1, 1);
    Assert.assertEquals(2,add);
    System.out.println("add = " + add);

    context.original = false;
    final DemoLogic demoLogic2 = demoLogic.get();
    final int addAdapted = demoLogic2.add(1, 1);
    Assert.assertEquals(102,addAdapted);
    System.out.println("addAdapted = " + addAdapted);
    }
    }
    &lt;/class&gt;&lt;/pre&gt;
I am using arquillian to have CDI support inside my jUnit Tests.&lt;br/&gt;
The annotation DynamicDecoratorTest is to separate this test from the rest of my tests.&lt;br/&gt;
&lt;br/&gt;
You see the usage quite clear. The developer will only see the interface. He will use it like &lt;br/&gt;
he will do it as normal. No change to see! Let´s asume the context switch is done by the system,&lt;br/&gt;
hidden, so the the develper is not able to see it. &lt;br/&gt;
He will write code only with the thinking about the business logic to implement.&lt;br/&gt;
&lt;br/&gt;
Afer we described what we want to have, we will implement the core. &lt;br/&gt;
To get an instance of the DemoLogic, we need a producer. We will call the class DemoLogicProducer.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class DemoLogicProducer {

    @Inject Instance&lt;DynamicObjectAdapterFactory&gt; dynamicObjectAdapterFactoryInstance;

    @Inject Context context;

    @Produces @DynamicDecoratorTest
    public DemoLogic create(ManagedInstanceCreator instanceCreator){
    final DemoLogic demoLogic = instanceCreator.activateCDI(new DemoLogic() {});

    final DynamicObjectAdapterFactory dynamicObjectAdapterFactory = dynamicObjectAdapterFactoryInstance.get();

    final Object adapter;
    if (context.original){
    adapter = new Object();
    } else {
    adapter = instanceCreator.activateCDI(new DemoLogicAdapter_A());
    }

    return dynamicObjectAdapterFactory.adapt(demoLogic, DemoLogic.class, adapter);
    }
    }
    &lt;/class&gt;&lt;/pre&gt;
The basic what we are simulating here ist the switch between original and customer specific.&lt;br/&gt;
This will be more comfortable in the next post. (using a ContextResolver)&lt;br/&gt;
But to show the basic step this is made explicite simple.&lt;br/&gt;
If the attribute is true, use the original one otherwise use the customer specific.&lt;br/&gt;
Very simple.. Both instances are manually put inside the CDI environment. &lt;br/&gt;
This ist only to show that the adapter itself can be managed too.&lt;br/&gt;
&lt;br/&gt;
The most importand step is the transparent wrapping with the DynamicObjectAdapterFactory.&lt;br/&gt;
The developer will not see this, until he is debugging ;-)&lt;br/&gt;
&lt;br/&gt;
How this factory is working? &lt;br/&gt;
The factory is using the java.lang.reflect.Proxy from the JDK itself. An old but very usefull class.&lt;br/&gt;
In my case I will use this in side a CDI managed environment. &lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class DynamicObjectAdapterFactory {

    @Inject Instance&lt;CDIInvocationHandler&gt; cdiInvocationHandlerInstance;

    public  &lt;T&gt; T adapt(final Object adaptee,final Class&lt;T&gt; target,final Object adapter) {

        final CDIInvocationHandler invocationHandler = cdiInvocationHandlerInstance
        .get()
        .adapter(adapter)
        .adaptee(adaptee);

        return (T) Proxy.newProxyInstance(
        target.getClassLoader(),
        new Class[]{target},
        invocationHandler
        );
        }

        }
        &lt;/class&gt;&lt;/pre&gt;
This means I will be able to inject, for example, the InvocationHandler. &lt;br/&gt;
This I need, because I need a managed InvocationHandler. &lt;br/&gt;
The usage of the Proxy is nothing complex. But the InvocationHandler is the final and importand step.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public class CDIInvocationHandler implements InvocationHandler {

    @Inject @CDILogger Logger logger;

    private Map&lt;MethodIdentifier, Method&gt; adaptedMethods = new HashMap&lt;&gt;();

    private Object adapter;
    private Object adaptee;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        if (adaptedMethods.isEmpty()){
            final Class&lt;?&gt; adapterClass = adapter.getClass();
            Method[] methods = adapterClass.getDeclaredMethods();
            for (Method m : methods) {
                adaptedMethods.put(new MethodIdentifier(m), m);
            }
        }else{
            if (logger.isDebugEnabled()) {
                logger.debug("adaptedMethods is initialized..");
            }
        }
        try {
            Method other = adaptedMethods.get(new MethodIdentifier(method));
            if (other != null) {
                return other.invoke(adapter, args);
            } else {
                return method.invoke(adaptee, args);
            }
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    public CDIInvocationHandler adapter(final Object adapter) {
        this.adapter = adapter;
        return this;
    }

    public CDIInvocationHandler adaptee(final Object adaptee) {
        this.adaptee = adaptee;
        return this;
    }


}

public class MethodIdentifier {
    private final String name;
    private final Class[] parameters;

    public MethodIdentifier(Method m) {
        name = m.getName();
        parameters = m.getParameterTypes();
    }

    // we can save time by assuming that we only compare against
    // other MethodIdentifier objects
    public boolean equals(Object o) {
        MethodIdentifier mid = (MethodIdentifier) o;
        return name.equals(mid.name) &amp;&amp;
                Arrays.equals(parameters, mid.parameters);
    }

    public int hashCode() {
        return name.hashCode();
    }
}

    &lt;/class&gt;&lt;/pre&gt;

The method invoke is called every time a method is called on the proxy. This is the place to decide which method will be called.&lt;br/&gt;
From the adapter we will get all methods and put them inside a HashMap. The key is based on method-name and attributes. &lt;br/&gt;
If a method is called with this key, we will get the adapter instance of this method from the map and &lt;br/&gt;
will call this instead of the original one.&lt;br/&gt;
If not key found, we will call the original nethod.&lt;br/&gt;
This is really simple!&lt;br/&gt;
&lt;br/&gt;
This means you have everywhere CDI managed instances.&lt;br/&gt;
You have only to implement what you whant to change.&lt;br/&gt;
It is dynamic with every request.&lt;br/&gt;
No beans.xml must be edited.&lt;br/&gt;
&lt;br/&gt;
You never need the decorator from CDI anymore. ;-)  &lt;br/&gt;
&lt;br/&gt;
Next step will be the integration iside an JavaFX controller.. and TestFX CDI Support&lt;br/&gt;
&lt;br/&gt;
&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-01-10&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>IoT with Java8 and TinkerForge Part 1</title>
        <category label="IoT"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="TinkerForge"/>
        <published>2014-01-13T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/01/13/iot-with-java8-and-tinkerforge-part-1.html" rel="tag"&gt;IoT with Java8 and TinkerForge Part 1&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-01-13"&gt;2014-01-13&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;IoT is something cool, but I think you know it already.&lt;br /&gt;
Today I started with TinkerForge.
TinkerForge is a german company that are building electronic elements. You can put them together like LEGO.
This means, that you don´t need any special electronic stuff or knowledge.
&lt;br /&gt;
And the best, you can code plain Java to use them.&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;But how we can start?
&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
First of all, you need a MasterBrick and at minimumm one sensor. For my first experiment I am using
the simple temperature sensor. After unpacking it I needed around 3 min to put all together.
After this you can plug it into your USB port. Now the hardware part is ready.
&lt;br /&gt;
&lt;br /&gt;
To speak with this components you have to install two things.&lt;br /&gt;
First the usb-driver, that is used for the communication with the MasterBrick,&lt;br /&gt;
second the BrickViewr. With this you can check the installation, update the firmware and so on.
&lt;br /&gt;
&lt;br /&gt;
You will find the software for&lt;b&gt; linux/osx/windows&lt;/b&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Hello IoT World:&amp;nbsp;&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
We will start with the first HelloWorld. Here with the Hello IoTWorld.&lt;br /&gt;
After you connected the MasterBrick with the USB-port you will see a blue light
and the MasterBrick will be ready for communication.
&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://1.bp.blogspot.com/-L4kMEQNQn7U/UtRZqJ_UlPI/AAAAAAABVGA/q_UgrGaqkdQ/s1600/SvenRuppert_IoT_TinkerForge_001_BrickV_001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-L4kMEQNQn7U/UtRZqJ_UlPI/AAAAAAABVGA/q_UgrGaqkdQ/s1600/SvenRuppert_IoT_TinkerForge_001_BrickV_001.jpg" height="140" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
Now we could start the BrickViewer to check the installation.
The importand part is the UID from the sensor. With this we can connect it later.
After you pressed the connect button, you can see all the informations.
&lt;br /&gt;
&lt;br /&gt;
At &lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt; are all source codes you will need, including the TinkerForge API itself.&lt;br /&gt;
I spoke with TinkerForge and we decided to put the API into maven.&lt;br /&gt;
&lt;br /&gt;
After we have done this, I will inform you.
If you are interested, follow me on Twitter please ( &lt;b&gt;&lt;a href="https://twitter.com/SvenRuppert"&gt;@SvenRuppert&lt;/a&gt;&lt;/b&gt; )
&lt;br /&gt;
&lt;br /&gt;
The basic steps are quite simple to use this sensor.&lt;br /&gt;
&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;create a IPConnection&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;create an instance of the class BrickletTemperature&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;configure the sensor&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;add an ActionListener.&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
That is all.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import com.tinkerforge.BrickletTemperature;
import com.tinkerforge.IPConnection;

public class ExampleCallback {
    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "dXj"; 
    public static void main(String args[]) throws Exception {
        IPConnection ipcon = new IPConnection(); 
        BrickletTemperature temp = new BrickletTemperature(UID, ipcon); 
        ipcon.connect(host, port); 
        temp.setTemperatureCallbackPeriod(1000);
        temp.addTemperatureListener(new 
          BrickletTemperature.TemperatureListener() {
            public void temperature(short temperature) {
                System.out.println("Temperature: " 
                   + temperature/100.0 + " °C");
            }
        });
        ipcon.disconnect();
    }
}
&lt;/pre&gt;
After this short example we could do our first javafx test.
We want to check the temperature over some time and show this inside an LineChart.&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-q7AnTcjRQz4/UtRaLcWsJFI/AAAAAAABVGI/lUAYpFuc87g/s1600/SvenRuppert_IoT_TinkerForge_001_Temp_001.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-q7AnTcjRQz4/UtRaLcWsJFI/AAAAAAABVGI/lUAYpFuc87g/s1600/SvenRuppert_IoT_TinkerForge_001_Temp_001.jpg" height="199" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Here we are... and please note, the DateAxis is from&lt;a href="http://myjavafx.blogspot.de/2013/09/javafx-charts-display-date-values-on.html"&gt; http://myjavafx.blogspot.de/2013/09/javafx-charts-display-date-values-on.html&lt;/a&gt;&lt;br /&gt;
&lt;pre class="brush: java"&gt; 
 public class HelloTinkerForge extends Application {

    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "dXj"; 


    public static void main(String args[]) throws Exception {
        launch(args);
    }

    public static XYChart.Series series;

    @Override
    public void start(Stage stage) {
        stage.setTitle("Line Chart TinkerForge Sample");
        final DateAxis dateAxis = new DateAxis();
        final NumberAxis yAxis = new NumberAxis();
        dateAxis.setLabel("Time of Temp");
        final LineChart&lt;date number=""&gt; lineChart
    = new LineChart&amp;lt;&amp;gt;(dateAxis, yAxis);

    lineChart.setTitle("Temp Monitoring");

    series = new XYChart.Series();
    series.setName("My temps");
    final ObservableList seriesData = series.getData();

    lineChart.getData().add(series);
    Scene scene = new Scene(lineChart, 800, 600);
    stage.setScene(scene);
    stage.show();
    new Worker(seriesData).start();

    }

    public static class Worker extends Thread {
    final ObservableList seriesData;
    public Worker(final ObservableList seriesData) {
    setDaemon(true);
    setName("Thread Temp");
    this.seriesData = seriesData;
    }

    @Override
    public void run() {
    Platform.runLater(new Runnable() {
    @Override
    public void run() {
    IPConnection ipcon = new IPConnection();
    BrickletTemperature temp
    = new BrickletTemperature(UID, ipcon);
    try {
    ipcon.connect(host, port);
    temp.setTemperatureCallbackPeriod(1000);
    temp.addTemperatureListener(
    new BrickletTemperature.TemperatureListener() {
    public void temperature(short temperature) {
    Platform.runLater(new Runnable() {
    @Override
    public void run() {
    final double temp
    = temperature / 100.0;
    final int counter
    = seriesData.size() + 1;
    final XYChart.Data data
    = new XYChart.Data(
    new Date(), temp);
    seriesData.add(data);
    }
    });
    }
    });
    } catch (IOException |
    AlreadyConnectedException |
    TimeoutException |
    NotConnectedException e) {
    e.printStackTrace();
    }
    }
    });
    }
    }
    }
&lt;/date&gt;&lt;/pre&gt;
&lt;pre class="brush: java"&gt;&lt;date number=""&gt;
&lt;/date&gt;&lt;/pre&gt;
Short and simple.. Well this is a simple example, but the next step will be with more sensor-elements...&lt;br /&gt;
&amp;nbsp;stay tuned..  and happy coding.&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-01-13&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>IoT with Java8 and TinkerForge Part 2</title>
        <category label="IoT"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="TinkerForge"/>
        <published>2014-01-20T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/01/20/iot-with-java8-and-tinkerforge-part-2.html" rel="tag"&gt;IoT with Java8 and TinkerForge Part 2&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-01-20"&gt;2014-01-20&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;One of the interesting features of &lt;a href="http://www.tinkerforge.com/"&gt;TinkerForge&lt;/a&gt; is the possibility to
put different elements like sensors, physical buttons, and more on a MasterBrick&lt;br /&gt;
&lt;br /&gt;
This is what we want to do today.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;The Barometer&lt;/b&gt;&lt;br /&gt;
Today we are using the &lt;a href="http://www.tinkerforge.com/en/doc/Hardware/Bricklets/Barometer.html"&gt;Barometer-Bricklet&lt;/a&gt;.
The Barometer Bricklet can be used to extend the features of Bricks
by the capability to measure air pressure in range of 10 to 1200mbar
with a resolution of 0.012mbar. The measurement is temperature
compensated internally. The Bricklet is equipped with
a MS5611-01BA01 sensor which is designed to be used as an altimeter, too.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;At &lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt; are all source codes you will need, including the TinkerForge API itself.
    I spoke with TinkerForge and we decided to put the API into maven. After we have done this, I will inform you.
    If you are interested, follow me on Twitter please ( &lt;b&gt;@SvenRuppert&lt;/b&gt; )
&lt;/i&gt;&lt;br /&gt;
&lt;br /&gt;
The most interesting part for us today will be the presents of two sensors inside of one Bricklet.&lt;br /&gt;
How we can handle it and how we will get the data to the screen?&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Connect to n - Sensor-units&lt;/b&gt;&lt;br /&gt;
To remember... To connect to a sensor you need an instance of the representing class.
To get the value from the sensor you have to implement an ActionListener.
Here the short example from my last blog about TinkerForge. &lt;i&gt;(&lt;a href="http://www.rapidpm.org/2014/01/iot-with-java8-and-tinkerforge-part-1.html"&gt;engl&lt;/a&gt; /&lt;a href="http://jaxenter.de/artikel/Internet-of-Things-mit-Java-8-und-TinkerForge-Teil-1-170511"&gt; ger&lt;/a&gt;)&lt;/i&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import com.tinkerforge.BrickletTemperature;
import com.tinkerforge.IPConnection;
public class ExampleCallback {
  private static final String host = "localhost";
  private static final int port = 4223;
  private static final String UID = "dXj";
  public static void main(String args[]) throws Exception {
    IPConnection ipcon = new IPConnection();
    BrickletTemperature temp = new BrickletTemperature(UID, ipcon);
    ipcon.connect(host, port);
    temp.setTemperatureCallbackPeriod(1000);
    temp.addTemperatureListener(new
    BrickletTemperature.TemperatureListener() {
      public void temperature(short temperature) {
        System.out.println("Temperature: "
        + temperature/100.0 + " °C");
      }
    });
    ipcon.disconnect();
}
}
&lt;/pre&gt;
The same will be with the two sensor-units inside the Barometer-Bricklet.
The class name will be BrickletBarometer, and you have to implement two ActionListeners.
One for the air-pressure called AirPressureListener and one for the altitude called AltitudeListener.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class ExampleCallback {
    private static final String host = "localhost";
    private static final int port = 4223;
    private static final String UID = "jY4";

    public static void main(String args[]) throws Exception {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);
        ipcon.connect(host, port);
        b.setAirPressureCallbackPeriod(1000);
        b.setAltitudeCallbackPeriod(1000);
        b.addAirPressureListener(
                new BrickletBarometer.AirPressureListener() {
                    public void airPressure(int airPressure) {
                        System.out.println("Air Pressure: "
                                + airPressure / 1000.0 + " mbar");
                    }
                }
        );
        b.addAltitudeListener(new BrickletBarometer.AltitudeListener() {
            public void altitude(int altitude) {
                System.out.println("Altitude: " + altitude / 100.0 + " m");
            }
        });
        ipcon.disconnect();
    }
}
&lt;/pre&gt;
&lt;b&gt;Connection to JavaFX&lt;/b&gt;&lt;br /&gt;
The connection to JavaFX could be simple. The basic steps are always the same.
You have to start an Thread outside our JavaFX GUI Thread. Inside this thread you have to configure the sensor
and inside the run()- method you have to add the action listener.
All steps that are manipulating the GUI, you have to start again inside a Platform.runLater()
Now, we have to sensor-units. This means that we are doing this twice.
To reuse the code later, we are extracting it into an separate class.
If we would do it for the temperature sensor we used last time, it will look like the following.
&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Temp implements Runnable {

  private String UID;
  private ObservableList seriesData;

  public Temp(final String UID, final XYChart.Series series) {
      this.UID = UID;
      this.seriesData = series.getData();
  }

  @Override
  public void run() {
      IPConnection ipcon = new IPConnection();
      BrickletTemperature temp = new BrickletTemperature(UID, ipcon);
      try {
          ipcon.connect(Barometer.host, Barometer.port);
          temp.setTemperatureCallbackPeriod(1000);
          temp.addTemperatureListener(new BrickletTemperature.TemperatureListener() {
              public void temperature(short temperature) {
                  Platform.runLater(new Runnable() {
                      @Override
                      public void run() {
                          final double temp = temperature / 100.0;
                          System.out.println("Temperature: " + temp + " °C");
                          final XYChart.Data data = new XYChart.Data(new Date(), temp);
                          seriesData.add(data);
       }
                  });
              }
          });
      } catch (IOException 
       | AlreadyConnectedException 
    | TimeoutException 
    | NotConnectedException e) {
          e.printStackTrace();
      }
  }
}
&lt;/pre&gt;
For the Barometer-Bricklet I was writing two classes. One for the airpressure and one for the altitude.
Both are identically, with one difference. The implementation of the ActionListener.
Every sensor will put his data to a separate LineChart.&lt;br /&gt;
&amp;nbsp;This implementation is not perfect, because we are not disconnecting
from the sensor in the end, and for one Bricklet we have two representing classes.
Both instances are in a different thread.
But this is still running over a longer period. (at least a few days with my laptop)
How to encapsulate this in better way we will see in one of my next posts.

&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Altitude implements Runnable {

    private String UID;
    private ObservableList seriesData;

    public Altitude(final String UID, final XYChart.Series series) {
        this.UID = UID;
        this.seriesData = series.getData();
    }

    @Override
    public void run() {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);

        try {
            ipcon.connect(Barometer.host, Barometer.port);
            b.setAirPressureCallbackPeriod(1000);
            b.addAltitudeListener(new BrickletBarometer.AltitudeListener() {
                public void altitude(int altitude) {
                    System.out.println("Altitude: " + altitude / 100.0 + " m");
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            final double temp = altitude / 100.0;
                            final XYChart.Data data = new XYChart.Data(new Date(), temp);
                            seriesData.add(data);
                        }
                    });
                }
            });
        } catch (IOException | AlreadyConnectedException | TimeoutException | NotConnectedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Airpressure implements Runnable {

    private String UID;
    private ObservableList seriesData;

    public Airpressure(final String UID, final XYChart.Series series) {
        this.UID = UID;
        this.seriesData = series.getData();
    }

    @Override
    public void run() {
        IPConnection ipcon = new IPConnection();
        BrickletBarometer b = new BrickletBarometer(UID, ipcon);

        try {
            ipcon.connect(Barometer.host, Barometer.port);
            b.setAirPressureCallbackPeriod(1000);
            b.addAirPressureListener(new BrickletBarometer.AirPressureListener() {
                public void airPressure(int airPressure) {
                    System.out.println("Air Pressure: " + airPressure / 1000.0 + " mbar");
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            final double temp = airPressure / 1000.0 ;
                            final XYChart.Data data = new XYChart.Data(new Date(), temp);
                            seriesData.add(data);
                        }
                    });
                }
            });
        } catch (IOException 
     | AlreadyConnectedException 
     | TimeoutException 
     | NotConnectedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;
Putting all together we will get the following main.

&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;public class Barometer extends Application {
    public static final String host = "localhost";
    public static final int port = 4223;


    public static void main(String args[]) throws Exception {
        launch(args);
    }

    public static XYChart.Series seriesTemp = new XYChart.Series();
    public static XYChart.Series seriesAirpressure = new XYChart.Series();
    public static XYChart.Series seriesAltitude = new XYChart.Series();

    @Override
    public void start(Stage stage) {
        stage.setTitle("Line Chart TinkerForge Sample");

        final VBox box = new VBox();
        seriesTemp.setName("Temp");
        seriesAirpressure.setName("Airpressure");
        seriesAltitude.setName("Altitude");

        final ObservableList&lt;node&gt; boxChildren = box.getChildren();
        boxChildren.add(createLineChart("Temp", seriesTemp));
        boxChildren.add(createLineChart("Airpressure", seriesAirpressure));
        boxChildren.add(createLineChart("Altitude", seriesAltitude));

        Scene scene = new Scene(box, 2000, 1500);

        stage.setScene(scene);
        stage.show();
        Platform.runLater(new Temp("dXj", seriesTemp));
        Platform.runLater(new Airpressure("jY4", seriesAirpressure));
        Platform.runLater(new Altitude("jY4", seriesAltitude));
        }

        private LineChart createLineChart(final String chartName,final XYChart.Series series ){
        final DateAxis dateAxis = new DateAxis();
        dateAxis.setLabel("Time");
        final NumberAxis yAxis = new NumberAxis();

        final LineChart&lt;date number=""&gt; lineChart = new LineChart&amp;lt;&amp;gt;(dateAxis, yAxis);
            lineChart.setTitle(chartName);
            lineChart.getData().add(series);

            return lineChart;
            }
            }
        &lt;/date&gt;&lt;/node&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;i&gt;At&amp;nbsp;&lt;a href="https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge"&gt;https://bitbucket.org/rapidpm/jaxenter.de-0012-iot-tinkerforge&lt;/a&gt;&amp;nbsp;are all source codes you will need, including the TinkerForge API itself. I spoke with TinkerForge and we decided to put the API into maven. After we have done this, I will inform you. If you are interested, follow me on Twitter please (&amp;nbsp;&lt;b&gt;@SvenRuppert&lt;/b&gt;&amp;nbsp;)&lt;/i&gt;&lt;br /&gt;
&lt;i&gt;&lt;br /&gt;&lt;/i&gt;
Short and simple.. as always ..
But if we are using more sensors in a way like this, we will get performance problems.
To solve this we are connecting different &lt;b&gt;NoSQL&lt;/b&gt; systems soon. And we have to build the next version of JavaFX GUI-Elements...
.... stay tuned..  and happy coding.
&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-01-20&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>FXController with CDI managed DynamicObjectAdapter - Part 2</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="JDK8"/>
        <category label="Reflection"/>
        <category label="Weld"/>
        <published>2014-02-07T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/02/07/fxcontroller-with-cdi-managed-dynamico.html" rel="tag"&gt;FXController with CDI managed DynamicObjectAdapter - Part 2&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-02-07"&gt;2014-02-07&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;Based on my &lt;a href="http://www.rapidpm.org/2014/01/fxcontroller-with-cdi-managed.html"&gt;blog article part 1&lt;/a&gt; we want to integrate the DynamicObjectAdapter into an JavaFX application.
To remember: We have an interface called DemoLogic with two methods. add(..) and sub(..)
The implementation is really simple, but at runtime we could switch the implementation partially.
For this we needed an adapter.
&lt;br/&gt;
The biggest tdifference compared to the default CDI decorator was,
that we need no definition inside the beans.xml. The implementation is smaller
and no need for Qualifiers and other biolder-plate code.
&lt;br/&gt;
This DemoLogic we want to use now inside an JavaFX application.
For this we ned first an fxml.file called DemoPane.fxml. Here we will define a few elements.

&lt;br /&gt;
&lt;pre class="brush: javafx"&gt;
&amp;lt;?import javafx.scene.control.Button?&amp;gt;
&amp;lt;?import javafx.scene.control.TextField?&amp;gt;
&amp;lt;?import javafx.scene.layout.VBox?&amp;gt;
&amp;lt;?import javafx.scene.control.Label?&amp;gt;
&amp;lt;?import javafx.scene.control.CheckBox?&amp;gt;
&amp;lt;fx:root type=&amp;quot;javafx.scene.layout.AnchorPane&amp;quot;
            xmlns:fx=&amp;quot;http://javafx.com/fxml&amp;quot;&amp;gt;
    &amp;lt;children&amp;gt;
        &amp;lt;VBox&amp;gt;
            &amp;lt;children&amp;gt;
                &amp;lt;Button fx:id=&amp;quot;button&amp;quot; text=&amp;quot;Hello World&amp;quot; /&amp;gt;
                &amp;lt;CheckBox fx:id=&amp;quot;checkbox&amp;quot; text=&amp;quot;switch context&amp;quot;/&amp;gt;
                &amp;lt;TextField fx:id=&amp;quot;textFieldA&amp;quot;/&amp;gt;
                &amp;lt;TextField fx:id=&amp;quot;textFieldB&amp;quot;/&amp;gt;
                &amp;lt;Label fx:id=&amp;quot;label&amp;quot;/&amp;gt;
            &amp;lt;/children&amp;gt;
        &amp;lt;/VBox&amp;gt;

    &amp;lt;/children&amp;gt;

&amp;lt;/fx:root&amp;gt;
    &lt;/class&gt;&lt;/pre&gt;

With the button we will activate the calculation, with the checkbox we will switch the context.
To have a small as possible implementation, there is no error checking.
&lt;br/&gt;
The next will be the controller called DemoController. This is a normal JavaFX Controller, but CDI managed.
How to get this? Well there is a good blog article here ;-) &lt;a href="http://www.rapidpm.org/2013/08/javafxcdi-bootstrap-add-on.html"&gt;CDI JavaFX bootstrapping&lt;/a&gt;.
&lt;br/&gt;
Inside the DemoController we will get an Instance of the DemoLogic and the Context.
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Inject
    @DynamicDecoratorTest
    Instance&amp;lt;DemoLogic&amp;gt; demoLogicInstance;

    @Inject
    Context context;
    &lt;/class&gt;&lt;/pre&gt;

The full implementation will be like the following.
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@DynamicDecoratorTest
public class DemoController implements Initializable{

    @FXML public TextField textFieldA;
    @FXML public TextField textFieldB;
    @FXML public Button button;
    @FXML public Label label;
    @FXML public CheckBox checkbox;

    @Inject
    @DynamicDecoratorTest
    Instance&amp;lt;DemoLogic&amp;gt; demoLogicInstance;

    @Inject
    Context context;

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        button.setText(&amp;quot;klick me&amp;quot;);
        button.setOnAction(actionEvent -&amp;gt; {

            final DemoLogic demoLogic = demoLogicInstance.get();

            final String textFieldAText = textFieldA.getText();
            final Integer a = Integer.valueOf(textFieldAText);

            final String textFieldBText = textFieldB.getText();
            final Integer b = Integer.valueOf(textFieldBText);

            final int result = demoLogic.add(a, b);
            label.setText(result+&amp;quot;&amp;quot;);

        });

        checkbox.setOnAction(actionEvent -&amp;gt; {
            context.original = checkbox.isSelected();
        });
    }
}
    &lt;/class&gt;&lt;/pre&gt;

Inside the method initialize you will find the connection between the GUI logic and the business logic.
This is now clean devided.
&lt;br/&gt;
To test this I was using Arquillian. LAter we will see how we could do this with TestFX.
We are working on the CDI Support.

&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@RunWith(Arquillian.class)
public class DemoLogicTest {
    @Deployment
    public static JavaArchive createDeployment() {
        return ShrinkWrap.create(JavaArchive.class)
                .addPackages(true, &amp;quot;org.rapidpm.demo&amp;quot;)
                .addPackages(true, &amp;quot;junit.org.rapidpm.demo&amp;quot;)
                .addPackages(true, &amp;quot;demo&amp;quot;)
                .addAsManifestResource(EmptyAsset.INSTANCE, &amp;quot;beans.xml&amp;quot;);
    }

    @Inject @DynamicDecoratorTest
    Instance&amp;lt;DemoController&amp;gt; demoControllerInstance;
    @Inject
    Context context;

    static final FXMLLoader loader = new FXMLLoader();

    @Test
    public void testDemoLogicJavaFXTest() throws Exception {
        loader.setControllerFactory(param -&amp;gt; demoControllerInstance.get());
        Application.launch(DemoApp.class);
    }


    public static class DemoApp extends Application {
        @Override
        public void start(Stage stage) throws Exception {

            final URL resource = getClass()
                    .getClassLoader()
                    .getResource(&amp;quot;DemoPane.fxml&amp;quot;);
            loader.setLocation(resource);
            final DemoController controller = (DemoController) loader
                    .getControllerFactory()
                    .call(DemoController.class);
            try {

                loader.setController(controller);
                loader.setRoot(new AnchorPane());
                final Parent root = (Parent) loader.load();

                stage.setScene(new Scene(root));
                stage.setTitle(&amp;quot;Custom Control&amp;quot;);
                stage.setWidth(300);
                stage.setHeight(200);
                stage.show();
            } catch (IOException exception) {
                throw new RuntimeException(exception);
            }

        }

        public static void main(String[] args) {
            launch(args);
        }
    }
}
    &lt;/class&gt;&lt;/pre&gt;
&lt;br/&gt;
You never need the decorator from CDI anymore. ;-)  &lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-02-07&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>JDK8/Streams are cool? Here is the answer. ;-)</title>
        <category label="Java"/>
        <category label="JDK8"/>
        <category label="Streams"/>
        <published>2014-02-10T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/02/10/jdk8-streams-are-cool-here-is-the-answ.html" rel="tag"&gt;JDK8/Streams are cool? Here is the answer. ;-)&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-02-10"&gt;2014-02-10&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;Today I was preparing a few slides for my next JUG talk.
For this if started with a normal piece of code like the following.

&lt;br/&gt;
&lt;pre class="brush: java"&gt;  
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        final List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; resultMatrix = new ArrayList&amp;lt;&amp;gt;();
        final Random random = new Random();
        for(int anzahlKurven = 0; anzahlKurven &amp;lt;ANZAHL_KURVEN; anzahlKurven++){
            final List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
            for (int i = 0; i &amp;lt; 10; i++) {
                final int nextInt = random.nextInt(100);
                result.add(nextInt);
            }
            resultMatrix.add(result);
        }
        return resultMatrix;
    }

    &lt;/class&gt;&lt;/pre&gt;
Next step would be the creation of two methods...
&lt;br/&gt;
&lt;pre class="brush: java"&gt;  
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        final List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        for(int anzahlKurven = 0; anzahlKurven &amp;lt;ANZAHL_KURVEN; anzahlKurven++){
            final List&amp;lt;Integer&amp;gt; demoValuesForY = generateDemoValuesForY();
            result.add(demoValuesForY);
        }
        return result;
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY() {
        final Random random = new Random();
        final List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 10; i++) {
            final int nextInt = random.nextInt(100);
            result.add(nextInt);
        }
        return result;
    }
    &lt;/class&gt;&lt;/pre&gt;
Ok, look´s like always... booooring.... So I started with Streams..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream
                .generate(this::generateDemoValuesForY)
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY(){
        final Random random = new Random();
        return Stream
                .generate(() -&amp;gt; {
                    return random.nextInt(100);
                })
                .limit(10)
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
Not really better.. only new syntax.. now reducing the syntax..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream
                .generate(this::generateDemoValuesForY)
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY(){
        final Random random = new Random();
        return Stream
                .generate(() -&amp;gt; random.nextInt(100))
                .limit(10)
                .collect(Collectors.toList());
    }

    &lt;/class&gt;&lt;/pre&gt;
But Random offer something new.
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream
                .generate(this::generateDemoValuesForY)
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    public List&amp;lt;Integer&amp;gt; generateDemoValuesForY(){
        return new Random()
                .ints(0, 100)
                .limit(10)
                .boxed()
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
Combining both methods..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        final Random random = new Random();
        return Stream.generate(
                    () -&amp;gt; Stream.generate(
                            () -&amp;gt; random.nextInt(100))
                            .limit(10)
                            .collect(Collectors.toList())
                )
                .limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
OK, not short enough.. we could it better..
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return Stream.generate(
                () -&amp;gt; new Random()
                        .ints(0, 100)
                        .limit(10)
                        .boxed()
                        .collect(Collectors.toList())
                ).limit(ANZAHL_KURVEN)
                .collect(Collectors.toList());
    }
    &lt;/class&gt;&lt;/pre&gt;
Uuuppsss..  static imports possible.. ;-)
&lt;br/&gt;
&lt;pre class="brush: java"&gt;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generateDemoValueMatrix() {
        return generate(() -&amp;gt; new Random()
                .ints(0, 100)
                .limit(10).boxed().collect(toList())
        ).limit(ANZAHL_KURVEN).collect(toList());
    }
    &lt;/class&gt;&lt;/pre&gt;

Now compare with the first  and decide ;-) Streams are cool ? I think so!!
&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-02-10&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Raspberry Wildfly Cluster for less than 300EUR</title>
        <category label="IoT"/>
        <category label="JBoss"/>
        <category label="JDK8"/>
        <category label="Raspberry PI"/>
        <category label="Wildfly"/>
        <published>2014-02-13T00:00:00+01:00</published>
        <author>
            <name>Alexander Bischof</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/02/13/raspberry-wildfly-cluster-for-less-tha.html" rel="tag"&gt;Raspberry Wildfly Cluster for less than 300EUR&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-02-13"&gt;2014-02-13&lt;/time&gt; &lt;a href="/team/alexander-bischof" rel="author"&gt;from Alexander Bischof&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;So WildFly 8 is final now.&lt;br /&gt;
In this article i like to show how you can create a development/testing wildly cluster with raspberry pis and only one power supply.&lt;br /&gt;
&lt;br /&gt;
I have bought:&lt;br /&gt;
&lt;ul&gt;
    &lt;li&gt;5x Raspberry Pis (Model B) with Wireless USB-Adapters&lt;/li&gt;
    &lt;li&gt;1x 10-Port USB 2.0 Hub&lt;/li&gt;
    &lt;li&gt;5x USB to Micro USB Adpapter&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://2.bp.blogspot.com/-kpQJO9A_2ls/UvldlgnYDdI/AAAAAAAAAAk/W-_zu4KexQQ/s1600/Foto.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-kpQJO9A_2ls/UvldlgnYDdI/AAAAAAAAAAk/W-_zu4KexQQ/s1600/Foto.JPG" height="400" width="300" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;
    &lt;br /&gt;&lt;/div&gt;
The Raspberries are configured with Raspbian Wheezy (wlan auto), JDK 8 and Wildfly 8 Final.&lt;br /&gt;
&lt;div&gt;
    In this combination you have to remove the '-server' from the domain.sh otherwise WildFly won't start.&lt;/div&gt;
&lt;br /&gt;
The WildFly Configuration can be made within 5 minutes.&lt;br /&gt;
&lt;ol&gt;
    &lt;li&gt;Master&lt;/li&gt;
    &lt;ol&gt;
        &lt;li&gt;Create management user admin (./add-user.sh)&lt;/li&gt;
        &lt;li&gt;Create a management slave user for each of your pi slaves (./add-user.sh)&lt;/li&gt;
        &lt;ul&gt;
            &lt;li&gt;Remember the secret value at the end of this process for each slave (e.g.&lt;span style="font-family: Menlo; font-size: 11px;"&gt;&amp;lt;secret value="MTIzNDU=" /&amp;gt;&lt;/span&gt;)&lt;/li&gt;
        &lt;/ul&gt;
        &lt;li&gt;Bind the interfaces to the public interface (e.g. 192.168.0.103)&amp;nbsp;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;li&gt;Slave&lt;/li&gt;
    &lt;ol&gt;
        &lt;li&gt;Configure host.xml with the slave name of 1.1&lt;/li&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;div style="font-family: Menlo; font-size: 11px;"&gt;
                &amp;lt;host name="slave1" xmlns="urn:jboss:domain:2.0"&amp;gt;&lt;/div&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;li&gt;Configure the server identity&lt;/li&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;div style="font-family: Menlo; font-size: 11px;"&gt;
                &amp;lt;server-identities&amp;gt;
                &amp;lt;secret value="MTIzNDU="/&amp;gt;
                &amp;lt;/server-identities&amp;gt;
            &lt;/div&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;li&gt;Bind the interfaces to master and public interface (e.g. 192.168.0.104)&lt;/li&gt;
        &lt;ul&gt;
            &lt;li&gt;To simply the typing i have written a small script that takes the master-ip and the bind-ip&lt;/li&gt;
&lt;span style="font-family: Menlo; font-size: 11px;"&gt;&lt;pre&gt;#MasterAdress
MASTER_ADDRESS=$1

# Bind Addresses
BIND_ADDRESS=$2

JBOSS_BIND_ADDRESS_MANAGEMENT=$BIND_ADDRESS
JBOSS_BIND_ADDRESS=$BIND_ADDRESS
JBOSS_BIND_ADDRESS_UNSECURE=$BIND_ADDRESS

sudo ./domain.sh -Djboss.bind.address.unsecure=$JBOSS_BIND_ADDRESS_UNSECURE -Djboss.bind.address.management=$BOSS_BIND_ADDRESS_MANAGEMENT -Djboss.bind.address=$JBOSS_BIND_ADDRESS -Djboss.domain.master.address=$MASTER_ADDRESS&lt;/pre&gt;
&lt;/span&gt;

        &lt;/ul&gt;
    &lt;/ol&gt;
&lt;/ol&gt;
Ready. Now you can deploy any archive either to main-server-group (just a domain) or other-server-group (full cluster).&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;/div&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;/div&gt;
&lt;br /&gt;&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/alexander-bischof" rel="author"&gt;Alexander Bischof&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-02-13&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
</feed>
