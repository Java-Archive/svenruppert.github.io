<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>jUnit</title>
    <category label="jUnit"/>
    <updated>2015-01-10T01:39:11.565+01:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <entry>
        <title>JavaEE - Arquillian - first version to play</title>
        <category label="Arquillian"/>
        <category label="IDEA"/>
        <category label="IntelliJ"/>
        <category label="Java"/>
        <category label="JBoss"/>
        <category label="jUnit"/>
        <published>2013-05-29T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2013/05/29/javaee-arquillian-first-version-to-pla.html" rel="tag"&gt;JavaEE - Arquillian - first version to play&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2013-05-29"&gt;2013-05-29&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;Heute geht es um Arquillian und wie man ein Basisgerüst für die eigene Entwicklung aufbauen kann. Das Hier vorgestellte Projekt kann als Vorlage für eigene verwendet werden und ist die Vorbereitung für den eigenen Einsatz in einem neuen Projekt. Also kann ich es hier auch gleich ein wenig dokumentieren &amp;nbsp;;-)&lt;br /&gt;
Hier in dem Projekt wird JDK 8 verwendet, die Konfiguration selbst ist aber bis auf die Compiler-Anweisung neutral.&lt;br /&gt;
kurz: Was ist Arquillian?&lt;br /&gt;
Arquillian ist ein Framework um Tests in den JEE-Containern selbst laufen zu lassen. Soll bedeuten: Es hilft dabei die jUnit-Tests in embedded oder lokal oder remote ApplikationsServern auszuführen.&lt;br /&gt;
&lt;a href="http://arquillian.org/" target="_blank"&gt;Arquillian Homepage&lt;/a&gt; –&amp;gt; Unter &lt;a href="https://bitbucket.org/svenruppert/javaee-arquillian" target="_blank"&gt;Bitbucket - JavaEE – Arquillian&lt;/a&gt; sind alle Sourcen in einem Git-Repository.&lt;br /&gt;
&lt;br /&gt;
Zu Beginn werden die Grundlagen in der pom.xml definiert. Wichtig hierbei ist, dass nur die generischen Teile global definiert werden, die containerabhängigen Dinge in den Profilen. Damit wird erreicht, das durch die Auswahl des Profils der Laufzeitcontainer gewechselt/definiert wird. In der Pom habe ich die Konfiguration für GlassFish, Jboss und einen einfachen Weld-Container hinterlegt.&lt;br /&gt;
Interessant ist der Abschnitt im Profil &lt;strong&gt;arquillian-jbossas-managed&lt;/strong&gt;. Unter &lt;strong&gt;build-&amp;gt;testRessourcen&lt;/strong&gt; ist ein Beispiel zu sehen wie man für den jeweiligen Container eigene Ressourcen definiert.&lt;br /&gt;
&lt;br /&gt;
Die nächste Konfigurationsstelle ist die Datei&amp;nbsp; test/ressourcen/arquillian.xml. Hier können die Container selbst mit Konfigurationen belegt werden. In diesem Beispiel habe ich für den jbossas-managed gezeigt, wie man auf eine eigene Version eines JBoss zugreifen kann. Das ist notwendig, wenn man in den Embedded-Tests z.B. Oracle Treiber für DataSourcen benötigt. Es werden also alle Konfigurationen verwendet, die man evtl schon vorgenommen hat.&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-88ntwCjrxVs/UaYkpOkzu3I/AAAAAAABQ2U/MRKWHjikjAA/s1600-h/image%25255B5%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-x0-zBfvvHvc/UaYkpyqTrQI/AAAAAAABQ2c/KyaLL5jY_Y0/image_thumb%25255B3%25255D.png?imgmax=800" height="388" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="865" /&gt;&lt;/a&gt;&lt;br /&gt;
Remote Test auf einem JBoss.&lt;br /&gt;
Um einen Test in einem Remote JBoss auszuführen, muss der Jboss zuerst gestartet werden. Wenn dieser hochgefahren ist, kann der Test via maven ausgeführt werden. In diesem Beispiel gehe ich davon aus, das der jboss auf localhost läuft.&lt;br /&gt;
In der Datei arquillian.xml unter &lt;strong&gt;jbossas-remot&lt;/strong&gt; ist der Port für den Debugger zu setzen. in meinem Fall 52197 was der Defaulteinstellung unter IntelliJ entspricht.&lt;br /&gt;
&lt;br /&gt;
Mit den Einstellungen kann schon begonnen werden. clean, compile, test. ;-)&lt;br /&gt;
Demnächst dann mehr mit praktischen Dingen…&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2013-05-29&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI Commons - Dynamic Service Resolver</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="IDEA"/>
        <category label="IntelliJ"/>
        <category label="Java"/>
        <category label="jUnit"/>
        <category label="Weld"/>
        <published>2013-06-26T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2013/06/26/cdi-commons-dynamic-service-resolver.html" rel="tag"&gt;CDI Commons - Dynamic Service Resolver&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2013-06-26"&gt;2013-06-26&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;&lt;p&gt;In meinem Blog über CDi und i18n (&lt;a href="http://www.rapidpm.org/2013/06/cdi-commons-i18n.html" target="_blank"&gt;Artikel&lt;/a&gt;) hatte ich einen PropertyRegistryService vorgestellt.&lt;/p&gt; &lt;p&gt;Als Beispiel wurde der Producer für die Instanz eines SimpleDateFormat gezeigt. &lt;/p&gt; &lt;p&gt;&lt;a href="http://lh3.ggpht.com/-uHPakGHkaOQ/UcrzhykV6lI/AAAAAAABSKM/U5BFjin6KH4/s1600-h/image%25255B3%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-nl3-2Ew87K8/UcrzihB3ncI/AAAAAAABSKU/f0Z4x6v8JGU/image_thumb%25255B1%25255D.png?imgmax=800" width="644" height="284"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Nicht schön war die harte Kopplung der Implementierung des PropertyRegistryService. Per Annotation wurde&lt;/p&gt; &lt;p&gt;die Implementierung deklariert. &lt;strong&gt;@CDIPropertyRegistryFileBased&lt;/strong&gt; (im Blog noch @CDIFileBased)&lt;/p&gt; &lt;p&gt;Immer wieder muss aber zur Laufzeit entschieden werden welche Implementierung verwendet werden soll/muss.&lt;/p&gt; &lt;p&gt;Das kann verschiedene Gründe haben wie z.B. das derzeitige Lastverhalten, der angemeldete User und und und.&lt;/p&gt; &lt;p&gt;Wie also die Endscheidung vornehmen? &lt;/p&gt; &lt;p&gt;Zwei Dinge sind notwendig:&lt;/p&gt; &lt;p&gt;1) Das Interface der implementierenden Klasse, in unserem Fall PropertyRegistryService&lt;/p&gt; &lt;p&gt;2) und der Qualifier um den richtigen Producer zu selektieren.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh6.ggpht.com/-h00St984Puw/UcrzjsYJWqI/AAAAAAABSKY/_tdGiHgBOtM/s1600-h/image%25255B10%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-qqqZ7bBXoYU/UcrzkSEbvAI/AAAAAAABSKk/uysM0o1UCdo/image_thumb%25255B6%25255D.png?imgmax=800" width="1028" height="436"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;Das Interface ist relativ leicht zu ermitteln. Mann kann es fest angeben, da man weiß das man genau dieses Interface benötigt.&lt;/p&gt; &lt;p&gt;Wenn auch das dynamisch ermittelt werden muss, kann man hier ähnlich wie bei den MessageRessourcen vorgehen. Es wird ein Key übergeben, der an anderer Stelle auf ein Interface gemappt wird. Hier einfach simuliert durch die Methode &lt;/p&gt; &lt;p&gt;&lt;strong&gt;Class mapp2Class(final String key)&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Spannender wird es bei der Auswahl der richtigen Qualifiers. Das ist der Kern der Implementierung.&amp;nbsp; Simuliert wird es hier &lt;/p&gt; &lt;p&gt;durch die Methode &lt;strong&gt;resolveContextImpl().&lt;/strong&gt; Wie genau die Implementierung aussehen kann, hängt von der Umgebung ab und welche Parameter ausgewertet werden müssen.&lt;/p&gt; &lt;p&gt;Die Implementierung hier erzeugt ein &lt;strong&gt;AnnotationLiteral&amp;lt;CDIPropertyRegistryFileBased&amp;gt;.&lt;/strong&gt; Das ist wieder eine harte Kopplung, kann jedoch wieder durch einen Mappingmechanismus zur Laufzeit aufgelöst werden.&amp;nbsp; Am einfachsten,&amp;nbsp; in dem man eine Klasse dynamisch instanziiert, die von AnnotationLitaral erbt.&lt;/p&gt; &lt;p&gt;z.B.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh6.ggpht.com/-G1N0nxPr5Jw/UcrzlHIDuvI/AAAAAAABSKs/Los4mxtfuRs/s1600-h/image%25255B14%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-y0L-RO_BVbQ/Ucrzl2JaOdI/AAAAAAABSK0/H3f7eFzzq1Y/image_thumb%25255B8%25255D.png?imgmax=800" width="644" height="118"&gt;&lt;/a&gt;&lt;/p&gt;  &lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2013-06-26&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Hot Swap in Java with DCEVM</title>
        <category label="IDEA"/>
        <category label="Java"/>
        <category label="jUnit"/>
        <category label="Tools"/>
        <published>2013-07-12T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2013/07/12/hot-swap-in-java-with-dcevm.html" rel="tag"&gt;Hot Swap in Java with DCEVM&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2013-07-12"&gt;2013-07-12&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;Immer auf der Suche nach neuen Werkzeugen…&amp;nbsp; Hier DCEVM (&lt;a href="http://ssw.jku.at/dcevm/" target="_blank"&gt;http://ssw.jku.at/dcevm/&lt;/a&gt;)&lt;br /&gt;
Und das beste: Es gibt es schon als intelliJ Plugin..&lt;br /&gt;
&lt;a href="http://blogs.jetbrains.com/idea/2013/07/get-true-hot-swap-in-java-with-dcevm-and-intellij-idea/" target="_blank"&gt;http://blogs.jetbrains.com/idea/2013/07/get-true-hot-swap-in-java-with-dcevm-and-intellij-idea/&lt;/a&gt;&lt;br /&gt;
das normale HotSwaping hat enge Grenzen sobald man an der Struktur der Klassen Veränderungen vornimmt. Hier gab es bisher immer noch das kommerzielle Werkzeug jRebel.&lt;br /&gt;
(Danke übrigens an das jRebel Team f die OSS Lizenz)&lt;br /&gt;
Nun gibt es eine OSS Lösung die genau an dieser Stelle weiterhilft. &lt;br /&gt;
Ich werde von meinen Tests berichten… &lt;img alt="Zwinkerndes Smiley" class="wlEmoticon wlEmoticon-winkingsmile" src="http://lh6.ggpht.com/-G022Pyxe_B0/Ud-RlflpOrI/AAAAAAABSkE/ULRusdSNp3Q/wlEmoticon-winkingsmile%25255B2%25255D.png?imgmax=800" style="border-bottom-style: none; border-left-style: none; border-right-style: none; border-top-style: none;" /&gt;&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2013-07-12&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI Transactions tested with Arquillian</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="IntelliJ"/>
        <category label="jUnit"/>
        <category label="Transactions"/>
        <category label="Weld"/>
        <published>2013-07-15T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2013/07/15/cdi-transactions-tested-with-arquillia.html" rel="tag"&gt;CDI Transactions tested with Arquillian&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2013-07-15"&gt;2013-07-15&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;&lt;p&gt;How to implement a scope like an transaction? The main goal was the reusability for an SE environment.&lt;/p&gt; &lt;p&gt;After a little bit google- searching I found the ConversationScope. A google start, but not usable in an SE environment.&lt;/p&gt; &lt;p&gt;So I started to write my own Scope. (&lt;a href="https://bitbucket.org/svenruppert/cdi-commons" target="_blank"&gt;Source –&amp;gt; Bitbucket&lt;/a&gt;) First step will be an annotation CDITransactionScope with the default Annotations.&lt;/p&gt; &lt;p&gt;The only new one is the annotation @NormalScope. With this annotation the container will use this as an Scope-Qualifier.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh4.ggpht.com/-8_n9oH0Dbm4/UeP4SKa0QwI/AAAAAAABSuU/2x_jChe15Qs/s1600-h/image%25255B8%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-y8G10V5KAP4/UeP4SmByerI/AAAAAAABSuc/8PSmYE4yWaU/image_thumb%25255B4%25255D.png?imgmax=800" width="644" height="100"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp; &lt;/p&gt; &lt;p&gt;The next step is the implementation of an extension. This is done by the class CDITransactionExtension extends Extension.&lt;/p&gt; &lt;p&gt;The interface Extension itself is empty and only a marker.&amp;nbsp; The task to full fill is the registration of an context. &lt;/p&gt; &lt;p&gt;The AfterBeanDiscovery event is used to add the instance of the context implementation. Important to know is, that at this point the init-phase of the weld-container is not ready.&lt;/p&gt; &lt;p&gt;No &lt;strong&gt;@Inject&lt;/strong&gt; is possible and the only instance that can be injected is the BeanManager.&amp;nbsp; &lt;/p&gt; &lt;p&gt;&lt;a href="http://lh5.ggpht.com/-w7ajr6R2Wpo/UeP4TMXBvSI/AAAAAAABSug/Fd7arvk8qqk/s1600-h/image%25255B12%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-UPQ2B0YHxyk/UeP4TWPOnnI/AAAAAAABSus/oiAHxpFRDzY/image_thumb%25255B6%25255D.png?imgmax=800" width="644" height="124"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;Finally we have to implement the heard of the transaction, the CDITransactionContext implements Context.&lt;/p&gt; &lt;p&gt;This is a class, not managed by the Container and again no &lt;strong&gt;@Inject&lt;/strong&gt; is possible, but the BeanManager&lt;/p&gt; &lt;p&gt;is usable. (see &lt;strong&gt;CDITransactionExtension&lt;/strong&gt; ) &lt;/p&gt; &lt;p&gt;Four methods are found to implement from the interface Context.&lt;/p&gt; &lt;p&gt;1) public Class&amp;lt;? extends Annotation&amp;gt; getScope()&lt;/p&gt; &lt;p&gt;2) public &amp;lt;T&amp;gt; T get(Contextual&amp;lt;T&amp;gt; contextual, CreationalContext&amp;lt;T&amp;gt; creationalContext);&lt;/p&gt; &lt;p&gt;3) public &amp;lt;T&amp;gt; T get(Contextual&amp;lt;T&amp;gt; contextual);&lt;/p&gt; &lt;p&gt;4) public boolean isActive();&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;Nr 2 and 3 are the important methods to implement. This methods are handling the instance-management.&lt;/p&gt; &lt;p&gt;The easiest implementation could be a map like HashMap&amp;lt;Class, Object&amp;gt;.&lt;/p&gt; &lt;p&gt;This implementation will cache all classes implementing the Interface Cacheable. (&lt;a href="https://bitbucket.org/rapidpm/genericcache" target="_blank"&gt;GenericCache&lt;/a&gt;) &lt;/p&gt; &lt;p&gt;If an Class is implementing this Interface it will be cached, otherwise you will always get a new instance.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh5.ggpht.com/-6bfsAetJgo0/UeP4UAQJKrI/AAAAAAABSu0/to6jHAfYi5Q/s1600-h/image%25255B21%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-Ox2h6Dou6EY/UeP4UkYhxPI/AAAAAAABSu8/mPyXJd_ZWrc/image_thumb%25255B11%25255D.png?imgmax=800" width="908" height="772"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;To activate this Extension, the class CDITransactionExtension must be registered in the file META-INF/javax.enterprise.inject.spi.Extension &lt;/p&gt; &lt;p&gt;with the full class name. &lt;/p&gt; &lt;p&gt;Now we can start writing transactions. &lt;/p&gt; &lt;p&gt;The Transaction (&lt;strong&gt;AbstractCDITransaction&lt;/strong&gt;) is an Executor-Pattern.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh6.ggpht.com/-qdFoduyDt0E/UeP4VeY1VOI/AAAAAAABSvA/q2Hsj9Z0Rkw/s1600-h/image%25255B26%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-wyJOQFyWvX4/UeP4V5E1H2I/AAAAAAABSvM/eQO5yuJdMEw/image_thumb%25255B14%25255D.png?imgmax=800" width="644" height="377"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;To Implement a transaction you have to implement an transaction – class with the method doIt().&lt;/p&gt; &lt;p&gt;Here is an excample with references inside and ad the same time outside of the active transaction.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh6.ggpht.com/-l69QbJiKoXU/UeP4WVnFc5I/AAAAAAABSvU/ueWyg9BvvOU/s1600-h/image%25255B30%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh5.ggpht.com/-tqIEH8iq9XI/UeP4Ww--MsI/AAAAAAABSvc/QK5bf-jKmJM/image_thumb%25255B16%25255D.png?imgmax=800" width="644" height="358"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;Inside the transaction are all instances with the Qualifier @&lt;strong&gt;CDITransactionScop&lt;/strong&gt; .&lt;/p&gt; &lt;p&gt;For this jUnitTest I implemented two Producers, one for the Instances inside the transaction and one for the outside one.&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh5.ggpht.com/-zUQhJDisv4Y/UeP4XQ1EfuI/AAAAAAABSvg/XzXjLsCJ1l4/s1600-h/image%25255B34%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh6.ggpht.com/-Zldm9h4o5E4/UeP4X_orOmI/AAAAAAABSvs/CsMKhkxeZqw/image_thumb%25255B18%25255D.png?imgmax=800" width="644" height="351"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;Finally the UML for this small demo.&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;a href="http://lh5.ggpht.com/-pMH_HP0lwT0/UeP4YZGo_CI/AAAAAAABSv0/2GoNh3uvdNU/s1600-h/image%25255B38%25255D.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh5.ggpht.com/-RKdm-qREa4Y/UeP4Y7e2MCI/AAAAAAABSv8/r9TFk6fpDuA/image_thumb%25255B20%25255D.png?imgmax=800" width="883" height="772"&gt;&lt;/a&gt;&lt;/p&gt;  &lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2013-07-15&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>CDI Commons - Dynamic Service Resolver</title>
        <category label="Arquillian"/>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="jUnit"/>
        <category label="Weld"/>
        <published>2013-07-17T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2013/07/17/cdi-commons-dynamic-service-resolver.html" rel="tag"&gt;CDI Commons - Dynamic Service Resolver&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2013-07-17"&gt;2013-07-17&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;In meinem Blog vom &lt;a href="http://www.rapidpm.org/2013/06/cdi-commons-dynamic-service-resolver.html" target="_blank"&gt;26.6.2013&lt;/a&gt; habe ich über die Möglichkeit geschrieben, wie man zur Laufzeit die &lt;br /&gt;
Implementierung auswählen kann die in die entsprechende Stelle injected wird.&lt;br /&gt;
Es war immer noch notwendig die Producer anzupassen wie in dem Beispiel des SimpleDateFormatterProducer&lt;br /&gt;
&lt;a href="http://lh6.ggpht.com/-3nOsUPRQFBY/UeZRhRWi8FI/AAAAAAABSyE/ydt6LTVhrd4/s1600-h/image%25255B4%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh4.ggpht.com/-Z1PL3KBjqb8/UeZRhzjaSxI/AAAAAAABSyM/HgBpBsB-kQ0/image_thumb%25255B2%25255D.png?imgmax=800" height="291" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="1028" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
Gleich mehrere Dinge die nicht angenehm sind. &lt;br /&gt;
1) der ContextResolver ist hier hart per Qualifier angegeben.&lt;br /&gt;
2) Die Implementierung eines Constructors selbst&lt;br /&gt;
3) Lazy-Init des AttributespropertyregistryService &lt;br /&gt;
4) fehlende Default Implementierung&lt;br /&gt;
&lt;br /&gt;
Aus Sicht der Entwickler wäre folgendes wünschenswert.&lt;br /&gt;
Ein Inject des PropertyregistryService mit folgender Anweisung: &lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-45yPDOnUJxw/UeZRiZrDRSI/AAAAAAABSyQ/Y1ZESUxf9YM/s1600-h/image%25255B23%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-I-yScB0k1CI/UeZRi_UnpXI/AAAAAAABSyc/3u4HtZS8jz0/image_thumb%25255B13%25255D.png?imgmax=800" height="37" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;br /&gt;
Um das zu erreichen wird die Klasse &lt;strong&gt;PropertyRegistryServiceProducer&lt;/strong&gt; implementiert.&lt;br /&gt;
Hier wird ein allgemeiner Producer für den PropertyregistryServcie geschrieben.&lt;br /&gt;
&lt;a href="http://lh4.ggpht.com/-sylKRPpui48/UeZRjfS06YI/AAAAAAABSyk/GXdNjNHsl28/s1600-h/image%25255B13%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh3.ggpht.com/-tfvsFsLLHiM/UeZRjzBZnlI/AAAAAAABSyo/ESmx0QU5_0o/image_thumb%25255B7%25255D.png?imgmax=800" height="544" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="1028" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
zwei Dinge sind hier von Bedeutung:&lt;br /&gt;
1) Der Inject einer Default-Implementierung , in diesem Fall der Inject einer FileBasedRegistry&lt;br /&gt;
2) Der Inject einers ContextResolvers mit @Any und @Default&lt;br /&gt;
Nun kann zur Laufzeit der ContextResolver ausgewertet werden um die Endscheidung zu treffen welche Implementierung verwendet werden soll.&lt;br /&gt;
Der ContextResolver selbst wird wohl immer eine spezialisierte Implementierung in einem Projekt darstellen und muss deshalb selbst Implementiert werden.&lt;br /&gt;
Eine Default-Implementierung ist dem Projekt als Beispiel in den test – Foldern beigelegt. (&lt;strong&gt;DefaultPropertyContextResolver&lt;/strong&gt;)&lt;br /&gt;
&lt;a href="http://lh3.ggpht.com/-TCFHS7F4WGA/UeZRkTfzDOI/AAAAAAABSyw/m0xYmEL6KP4/s1600-h/image%25255B18%25255D.png"&gt;&lt;img alt="image" border="0" src="http://lh5.ggpht.com/-JkhZXOORYrM/UeZRkqRcRnI/AAAAAAABSy8/vuUpFYsOYKw/image_thumb%25255B10%25255D.png?imgmax=800" height="162" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="image" width="644" /&gt;&lt;/a&gt;&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2013-07-17&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>JavaFX/CDI Bootstrap - Add On</title>
        <category label="CDI"/>
        <category label="CDICommons"/>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="jUnit"/>
        <published>2013-08-14T00:00:00+02:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2013/08/14/javafx-cdi-bootstrap-add-on.html" rel="tag"&gt;JavaFX/CDI Bootstrap - Add On&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2013-08-14"&gt;2013-08-14&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;A few days ago I was writing about the JavaFX/CDI Bootstrap. &lt;br /&gt;
There are a few small changings until now. &lt;br /&gt;
&lt;blockquote&gt;
&lt;em&gt;The final jUnit-Class (extends JavaFXBaseTest ) will implement the method –&amp;gt; testImpl(final Stage stage). &lt;/em&gt;&lt;br /&gt;
&lt;em&gt;The jUnit-Test will be a manged instance itself.&lt;/em&gt;&lt;/blockquote&gt;
This is right.. but I forgot to Inject the a few things.&lt;br /&gt;
First the JavaFX component that is managed:&lt;br /&gt;
The jUnit example (&lt;b&gt;CDIJavaFXBaseApplication001Test&lt;/b&gt;, you will find this at cdi-commons-fx) is using the LoginPane.&lt;br /&gt;
This is changed from an empty class to the following implementation&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
public class LoginPane extends GridPane {

    private @Inject FXMLLoaderSingleton fxmlLoaderSingleton;
    private @Inject LoginController controller;

    public LoginPane() {
    }

    @PostConstruct
    public void init(){
        final FXMLLoader fxmlLoader = fxmlLoaderSingleton.getFXMLLoader(LoginPane.class);
        fxmlLoader.setRoot(this);
        try {
            fxmlLoader.setController(controller);
            fxmlLoader.load();
        } catch (IOException exception) {
            throw new RuntimeException(exception);
        }
    }

    public LoginController getController() {
        return controller;
    }
}
]]&gt;&lt;/script&gt;
&lt;br /&gt;
Now you have to modify the fxml based on this first version.&lt;br /&gt;
&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
&lt;fx:root type="javafx.scene.layout.GridPane" fx:controller="demo.LoginController"
         alignment="CENTER" hgap="10.0" stylesheets="/demo/login.css" vgap="10.0"
          xmlns:fx="http://javafx.com/fxml"
          &gt;

   &lt;!-- .... --&gt;

&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;
&lt;br /&gt;
At this version you had to declare the controller itself. This can be done later by the init-phase. And the root – element was an pure GridPane.
&lt;br /&gt;
The new version looks like this:&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
&lt;fx:root type="demo.LoginPane"
         alignment="CENTER" hgap="10.0" stylesheets="/demo/login.css" vgap="10.0"
          xmlns:fx="http://javafx.com/fxml"&gt;

&lt;!-- .... --&gt;

&lt;/fx:root&gt;
]]&gt;&lt;/script&gt;

The root – element is now the self defined class LoginPane and the the controller definition is removed. So you can inject a controller at runtime depending on the ContextResolver.&lt;br /&gt;
&lt;br /&gt;
The jUnit-Test itself changed a little bit. At the first version we used the fxml-Loader to get the LoginPane.. This can now be done by an Inject. (@Inject LoginPane root; )&lt;br /&gt;
&lt;br /&gt;
&lt;script type="syntaxhighlighter" class="brush: js"&gt;&lt;![CDATA[
        @Inject
        @CDISimpleDateFormatter(value = "date.yyyyMMdd")
        SimpleDateFormat sdf;
        @Inject
        @CDILogger
        Logger logger;

        @Inject LoginPane root;

        @Override
        public void testImpl(Stage stage) {
            if (logger.isDebugEnabled()) {
                logger.debug("testrunn at -&gt; " + sdf.format(new Date()));
            }
            stage.setTitle("Login");  //i18n
            stage.setScene(new Scene(root, 300, 275));
            //stage.show();
            final Scene scene = stage.getScene();

            //TestCode
            final TextField login = (TextField) scene.lookup("#loginField");
            login.setText("LOGIN");
            final PasswordField passwd = (PasswordField) scene.lookup("#passwordField");
            passwd.setText("LOGIN");

            final LoginController controller = root.getController();
            controller.handleSubmitButtonAction(new ActionEvent());

            final Text feedback = (Text) scene.lookup("#feedback");
            Assert.assertEquals("LOGIN logged in successfully", feedback.getText());
        }

]]&gt;&lt;/script&gt;&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2013-08-14&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>TestFX internals explained</title>
        <category label="Java"/>
        <category label="JavaFX"/>
        <category label="jUnit"/>
        <category label="TestFX"/>
        <published>2014-01-03T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/01/03/testfx-internals-explained.html" rel="tag"&gt;TestFX internals explained&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-01-03"&gt;2014-01-03&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;TestFX a small but powerful framework for JavaFX GUI Testing with jUnit.&lt;br/&gt;
How it is used and how it is working inside?&lt;br/&gt;
&lt;br/&gt;
TDD for GUI development is for a lot of developers something that make them feeling uncomfortable.&lt;br/&gt;
Using jUnit for the testing of the GUI Elements is mostly not what you want to do. &lt;br/&gt;
But with TestFX it is quite simple to write short but reusable tests.&lt;br/&gt;
&lt;br/&gt;
Let´s start with the project initialization. You need only a few entries in you pom.xml.&lt;br/&gt;
jUnit, hamcrest and testfx, that is it.. and nothing more.&lt;br/&gt;

&lt;br /&gt;
&lt;pre class="brush: xml"&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.loadui&lt;/groupId&gt;
    &lt;artifactId&gt;testFx&lt;/artifactId&gt;
    &lt;version&gt;3.0.0 &lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
    &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
    &lt;version&gt;1.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
    &lt;/class&gt;&lt;/pre&gt;
After we added this entries to the pom.xml, we can start with the first jUnitTest using TestFX.&lt;br/&gt;
We will start with the traditional &lt;b&gt;HelloWorld&lt;/b&gt;. The first step is the creation of a TestClass.&lt;br/&gt;
The TestClass must extend from GuiTest, a base class from the TestFX Framework. &lt;br/&gt;
This class is abstract and you have to implement the method &lt;b&gt;protected Parent getRootNode()&lt;/b&gt;&lt;br/&gt;
This method must create the GUI element that you will test. I our example we want to test a simple button.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Category(TestFX.class)
public class SimpleButtonTest extends GuiTest {
    @Override
    protected Parent getRootNode() {
        final Button btn = new Button();
        btn.setId("btn");
        btn.setText("Hello World");
        btn.setOnAction((actionEvent)-&gt; btn.setText( "was clicked" ));
        return btn;
    }
}
    &lt;/class&gt;&lt;/pre&gt;
You can see, that you don´t have to create a holder for your GUI element.&lt;br/&gt;
Now we can start with the first test itself.&lt;br/&gt;
The button will change the text from "Hello World" to "was clicked" if the user will click the button.&lt;br/&gt;
How we can test this?&lt;br/&gt;

As normal we have to write a test method annotated with the @Test from jUnit.&lt;br/&gt;
The first question will be, how to get the reference of the button? &lt;br/&gt;
For this you can use one of the service methods. With find and the id you will get the instance.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Test
public void shouldClickButton(){
    final Button button = find( "#btn" );
    click(button);
    verifyThat( "#btn", hasText("was clicked") );
}
    &lt;/class&gt;&lt;/pre&gt;
As you can see, we can start with the functional tests after we got the reference. Here we are simulating the click.&lt;br/&gt;
After this we are checking if the result is as expected.&lt;br/&gt;
Writing tests looks now like , writing the use case with methods organized with the builder pattern.&lt;br/&gt;
If you want to write your own check like hasText() you have to write it with the framework hamcrest.&lt;br/&gt;
But TestFX will provide a lot of default checks and test-steps. Mostly you don not need more.&lt;br/&gt;
&lt;br/&gt;
But how TestFX is doing all this?&lt;br/&gt;
Starting with the test class GUITest, we know that we have to create the GUI element we want to test.&lt;br/&gt;
The class GUITest itself contains a lot of methods to describe the use case with &lt;br/&gt;
actions like click,drag,move,push, scroll, rightClick and so on.&lt;br/&gt;
But how the application is started? This will be done by the internal class TestFXApp inside GUITest. &lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
public static class TestFxApp extends Application
{
    private static Scene scene = null;

    @Override
    public void start( Stage primaryStage ) throws Exception
    {
        primaryStage.initStyle(StageStyle.UNDECORATED);
        primaryStage.show();
        stageFuture.set( primaryStage );
    }

    public static void setRoot( Parent rootNode )
    {
        scene.setRoot( rootNode );
    }
}
    &lt;/class&gt;&lt;/pre&gt;
Every developer that was writing the first few jUnit tests for an JavaFX application &lt;br/&gt;
came to the point where the JVM was telling something like &lt;br/&gt;
"please, only one instance of the JavaFX Application please"&lt;br/&gt;
How to deal with this?&lt;br/&gt;
The basic is quite simple. You have to start the application in one thread, save this as an singleton over all jUnit tests in one JVM.&lt;br/&gt;
After this, put every junit test method in one Callable and start them one after an other.&lt;br/&gt;
The first step will be done with the method setupStage, annotated with @Before.&lt;br/&gt;
Inside this there is a check if the singleton is already there or not. If not, it will be created. FXTestUtils.launchApp(TestFxApp.class);&lt;br/&gt;
After this the GUI element from getRootNode() will be placed in a new Runnable.&lt;br/&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;
@Before
public void setupStage() throws Throwable{
    showNodeInStage();
}

private void showNodeInStage(){
    showNodeInStage(null);
}

private void showNodeInStage( final String stylesheet ){
    GuiTest.stylesheet = stylesheet;

    if( stage == null ){
        FXTestUtils.launchApp(TestFxApp.class);
        try{
            stage = targetWindow(stageFuture.get( 25,TimeUnit.SECONDS ) );
            FXTestUtils.bringToFront( stage );
        }catch( Exception e ) {
            throw new RuntimeException( "Unable to show stage", e );
        }
    }

    try{
        FXTestUtils.invokeAndWait( new Runnable(){
            @Override
            public void run(){
                Scene scene = SceneBuilder
                    .create()width( 600 ) height( 400 )
                    .root( getRootNode() ).build();

                if(stylesheet!=null) 
                    scene.getStylesheets().add(stylesheet);
                stage.setScene( scene );
            }
        }, 5 );
    }catch( Exception e ) {
        e.printStackTrace();
    }
}

    &lt;/class&gt;&lt;/pre&gt;

That´s it. Quite simple and easy to use for a developer.&lt;br/&gt;
The good thing is, that TestFX is good usable in an CI environment. &lt;br/&gt;
You only have to configure jUnit if not already done.&lt;br/&gt;
&lt;br/&gt;
But this is not the end..  I am working in the moment at the full CDI support inside &lt;br/&gt;
TestFX. We will see it in one of the next versions from TestFX. stay tuned...&lt;br/&gt;
&lt;br/&gt;
If you have any ideas what we can improve..    let me know..&lt;br/&gt;
&lt;br/&gt;
happy javafx testing&lt;br/&gt;&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-01-03&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
</feed>
