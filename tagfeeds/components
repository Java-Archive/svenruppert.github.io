<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>components</title>
    <category label="components"/>
    <updated>2015-01-10T02:11:00.359+01:00</updated>
    <id>http://rapidpm.github.io</id>
    <author>
        <name>Sven Ruppert</name>
    </author>
    <entry>
        <title>Lego Mindstorms EV3 Components: Motors - Part 1</title>
        <category label="0.5.0"/>
        <category label="components"/>
        <category label="EV3"/>
        <category label="Lego"/>
        <category label="lejos"/>
        <category label="Mindstorms"/>
        <category label="motors"/>
        <published>2014-01-11T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/01/11/lego-mindstorms-ev3-components--motors.html" rel="tag"&gt;Lego Mindstorms EV3 Components: Motors - Part 1&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-01-11"&gt;2014-01-11&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;&lt;br /&gt;
With this posting I will start a series of articles where I explain which components/sensors are contained in the Lego Mindstorms EV3-set an how to work with them.&lt;br /&gt;
&lt;br /&gt;
In this posting I will start with one of the most basic components - the motors. The Mindstorms-set includes three motors: two of the same size and a smaller one.&lt;br /&gt;
&lt;br /&gt;
Both types work the same way and so they have the same api-methods.&lt;br /&gt;
&lt;br /&gt;
I will build a simple program were I let the robot perform some movements to different directions.&lt;br /&gt;
&lt;br /&gt;
Before we can start developing, we first need a robot which we will control with the program. I built a simple robot for that. It consists of only one single component connected to the brick: One of the bigger motors. There are two wheels plugged into the motor and two more wheels which aren't connected to the motor and just work as stabilization. Here are some pics:&lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://4.bp.blogspot.com/-gJ0BPfi2Pb0/Us6us3v_eeI/AAAAAAAAAIk/EenQtF2MY7M/s1600/DSCN0594.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-gJ0BPfi2Pb0/Us6us3v_eeI/AAAAAAAAAIk/EenQtF2MY7M/s1600/DSCN0594.JPG" height="240" width="320" /&gt;&lt;/a&gt;
&lt;a href="http://1.bp.blogspot.com/-lGWCS5TqS3s/Us6uusRK-GI/AAAAAAAAAIs/mEk-cZr8jKg/s1600/DSCN0596.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-lGWCS5TqS3s/Us6uusRK-GI/AAAAAAAAAIs/mEk-cZr8jKg/s1600/DSCN0596.JPG" height="240" width="320" /&gt;&lt;/a&gt;
&lt;a href="http://1.bp.blogspot.com/-Lp-Hs7-z_nw/Us6uzYNSw6I/AAAAAAAAAI8/eLNfIbfRkEg/s1600/DSCN0597.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-Lp-Hs7-z_nw/Us6uzYNSw6I/AAAAAAAAAI8/eLNfIbfRkEg/s1600/DSCN0597.JPG" height="320" width="240" /&gt;&lt;/a&gt;
&lt;a href="http://1.bp.blogspot.com/-4mXFS9dCiYg/Us6u4bC5xlI/AAAAAAAAAJM/XT-HV-eSpSg/s1600/DSCN0599.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-4mXFS9dCiYg/Us6u4bC5xlI/AAAAAAAAAJM/XT-HV-eSpSg/s1600/DSCN0599.JPG" height="240" width="320" /&gt;&lt;/a&gt;&lt;br /&gt;
( There are different ways at different abstract levels to control the motors, but I will use the most basic method by using the Motor-class directly in this first part. We couldn't use a more abstract method which enable features like driving turns or following paths because we only have a single motor connected to our robot here. So the robot can just move forwards and backwards. )&lt;br /&gt;
&lt;br /&gt;
I plugged the motor into plug connection B on the brick.&lt;br /&gt;
&lt;br /&gt;
So, now we are ready to develop the program for our new robot. I set up an IntelliJ-project as described in our posting about &lt;a href="http://www.rapidpm.org/2013/12/developing-lejos-programs-with-intellij.html"&gt;developing leJOS programs with IntelliJ on Windows&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
First, here is the plain code which is quite easy to understand:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.hardware.motor.Motor;
import lejos.utility.Delay;

public class Main {
    public static void main(String[] args) {

        Motor.B.setAcceleration(200);
        Motor.B.setSpeed(90);
        Motor.B.rotate(360);
        Motor.B.setSpeed(180);
        Motor.B.rotate(360);
        Motor.B.setSpeed(360);
        Motor.B.rotate(360);
        Motor.B.backward();
        Delay.msDelay(3000);
        Motor.B.stop();

    }
}
&lt;/pre&gt;
What does that code do?&lt;br /&gt;
We address the motor in plug connection B via Motor.B. Then we set its acceleration to 200. The standard value is 6000 which means that the motor will accelerate by 6000 degrees per second per second. This is quite fast and so we lowered the value to 200 to get a smoother acceleration.&lt;br /&gt;
Then we set the speed of the motor to 90 degrees per second. After we "configured" the motor, we let it start rotating by 360 degrees. This operation is a blocking operation which means that the program will stop here until the motor rotated 360 degrees (which will be done after 4 seconds at the configured speed of 90 degrees per second).&lt;br /&gt;
After the motor rotated 360 degrees we double the speed to 180 degrees per second and let the motor rotate 360 degrees again. This time the motor will need half the time (2 seconds), of course.&lt;br /&gt;
After that the same happens again with a speed of 360 degrees per second.&lt;br /&gt;
Then, as the last part of the program, we call the backward-method. In contrast to the rotate-method, this method is non-blocking. That means, that the program will continue directly after calling that method, it won't wait till the backwards-movement is done (otherwise the motor wouldn't stop rotating anymore, there is no parameter for defining how long the motor should rotate). Recognize that there is also a rotate()-method with a second, boolean parameter. If you use that one with the boolean parameter = true the method becomes non-blocking like backward(). &lt;br /&gt;
In the next line we tell the program to do nothing for 3 seconds, the motor will of course continue rotating (at the speed which was set as last = 360 degrees per second) during that time. &lt;br /&gt;
Then after these 3 seconds we let the motor stop und the program is at its end.&lt;br /&gt;
&lt;br /&gt;
To get some feedback on what the robot is exactly doing through the program execution, we added some printlns to the console.&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.hardware.motor.Motor;
import lejos.utility.Delay;

public class Main {
    public static void main(String[] args) {
        /*
        The standard value for acceleration is (6000 degrees per second) per second
        which results in a very jerky start when the motor starts rotating.
        To make the start smoother, the acceleration is set to a lower level.
         */
        Motor.B.setAcceleration(200);
        
        Motor.B.setSpeed(90);
        System.out.println("Set speed to 90 degrees per second.");
        System.out.print("Rotating 360 degrees...");
        Motor.B.rotate(360);
        System.out.println("done!");
        
        Motor.B.setSpeed(180);
        System.out.println("Set speed to 180 degrees per second.");
        System.out.print("Rotating 360 degrees...");
        Motor.B.rotate(360);
        System.out.println("done!");
        
        Motor.B.setSpeed(360);
        System.out.println("Set speed to 360 degrees per second...");
        System.out.print("Rotating 360 degrees...");
        Motor.B.rotate(360);
        System.out.println("done!");
        
        Motor.B.backward();
        System.out.print("Now rotating backwards for 3s");
        Delay.msDelay(3000);
        System.out.print("...3s are over...");
        Motor.B.stop();
        System.out.println("and stopped!");

    }
}
&lt;/pre&gt;
That code looks better now, but there's tons of duplicate code. So we put the code for setting different speeds and letting the motor rotate in a function.&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.hardware.motor.Motor;
import lejos.utility.Delay;

public class Main {
    public static void main(String[] args) {
        /*
        The standard value for acceleration is (6000 degrees per second) per second
        which results in a very jerky start when the motor starts rotating.
        To make the start smoother, the acceleration is set to a lower level.
         */
        Motor.B.setAcceleration(200);

        rotateDegreesAtSpeed(360, 90);
        rotateDegreesAtSpeed(360, 180);
        rotateDegreesAtSpeed(360, 360);

        Motor.B.backward();
        System.out.print("Now rotating backwards for 3s");
        Delay.msDelay(3000);
        System.out.print("...3s are over...");
        Motor.B.stop();
        System.out.println("and stopped!");

    }

    private static void rotateDegreesAtSpeed(final int degreesToRotate, final int degreesPerSecond) {
        Motor.B.setSpeed(degreesPerSecond);
        System.out.println("Set speed to "+degreesPerSecond+ "degrees per second.");
        System.out.print("Rotating "+ degreesToRotate + "degrees...");
        Motor.B.rotate(degreesToRotate);
        System.out.println("done!");
    }
}&lt;/pre&gt;
&lt;br /&gt;
That was it. After transfering the program onto the brick (via WiFi) we executed the program. Here's a video of how the result looks like (console output readable in higher qualities).&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;object class="BLOGGER-youtube-video" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="https://ytimg.googleusercontent.com/vi/qr14DFO60Tk/0.jpg" height="266" width="320"&gt;&lt;param name="movie" value="https://www.youtube.com/v/qr14DFO60Tk?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" /&gt;&lt;param name="bgcolor" value="#FFFFFF" /&gt;&lt;param name="allowFullScreen" value="true" /&gt;&lt;embed width="320" height="266"  src="https://www.youtube.com/v/qr14DFO60Tk?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Perfect. The next thing we did was extending the robot by a second motor - the smaller one. The result looked like the following:&lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://1.bp.blogspot.com/-eNXOOaEsic0/Us6u60ZBzHI/AAAAAAAAAJY/q4p4IaTrQIM/s1600/DSCN0600.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-eNXOOaEsic0/Us6u60ZBzHI/AAAAAAAAAJY/q4p4IaTrQIM/s1600/DSCN0600.JPG" height="240" width="320" /&gt;&lt;/a&gt;
&lt;a href="http://3.bp.blogspot.com/-SIUBBBpNqBk/Us6u9ehJ2VI/AAAAAAAAAJg/GP55djU9xZk/s1600/DSCN0601.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-SIUBBBpNqBk/Us6u9ehJ2VI/AAAAAAAAAJg/GP55djU9xZk/s1600/DSCN0601.JPG" height="240" width="320" /&gt;&lt;/a&gt;
&lt;a href="http://1.bp.blogspot.com/-tEuoOrBUdaY/Us6u_wRN4EI/AAAAAAAAAJo/Bp31UBL3OtY/s1600/DSCN0602.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-tEuoOrBUdaY/Us6u_wRN4EI/AAAAAAAAAJo/Bp31UBL3OtY/s1600/DSCN0602.JPG" height="240" width="320" /&gt;&lt;/a&gt;&lt;br /&gt;
So the second motor will make the three "razorblades" rotate ( some eyecandy :) ).&lt;br /&gt;
We put the second motor in plug connection A of the brick.&lt;br /&gt;
&lt;br /&gt;
The aim for that second motor should be: The razorblades should always rotate the same speed, the first motor has.&lt;br /&gt;
&lt;br /&gt;
So we extended our program. Here's the finished code:&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.hardware.motor.Motor;
import lejos.utility.Delay;

public class Main {
    public static void main(String[] args) {

        final int ACCELERATION = 200;
        final int ONE_ROTATION = 360;
        /*
        The standard value for acceleration is (6000 degrees per second) per second
        which results in a very jerky start when the motor starts rotating.
        To make the start smoother, the acceleration is set to a lower level.
         */
        Motor.B.setAcceleration(ACCELERATION);
        Motor.A.setAcceleration(ACCELERATION);

        Motor.A.forward();
        rotateDegreesAtSpeed(ONE_ROTATION, 90);
        rotateDegreesAtSpeed(ONE_ROTATION, 180);
        rotateDegreesAtSpeed(ONE_ROTATION, 360);

        Motor.A.backward();
        System.out.println("Switched Motor A from forward to backward. Waiting for the direction change.");
        Delay.msDelay(2000);
        Motor.B.backward();

        System.out.print("Now rotating backwards for 3s");
        Delay.msDelay(3000);
        System.out.print("...3s are over...");
        Motor.B.stop();
        Motor.A.stop();
        System.out.println("and stopped!");

    }

    private static void rotateDegreesAtSpeed(final int degreesToRotate, final int degreesPerSecond) {
        Motor.A.setSpeed(degreesPerSecond);
        Motor.B.setSpeed(degreesPerSecond);
        System.out.println("Set speed of motors to "+degreesPerSecond+ " degrees per second.");
        System.out.print("Rotating "+ degreesToRotate + " degrees...");
        Motor.B.rotate(degreesToRotate);
        System.out.println("done!");
    }
}&lt;/pre&gt;
At the beginning of the program we set the acceleration of motor A to 200, too. Then we call Motor.A.forward(), which is a non-blocking operation like the backward()-method. We added one line in the created function to set the speed for motor A which is the same as for motor B, of course. After the three function calls we first call bachwards() on motor A. This will make the motor stop as the first step, and then start rotating backwards in a second step. Recognize, that Motor.A.backward() will be called when motor B stopped rotating. To let the robot wait until motor A also stopped, we added a delay of two seconds. After these two seconds the robot will start turning backwards (motor B will rotate into the other direction). At the same time, motor A will start rotating in the other direction, too.&lt;br /&gt;
We will let the robot move backwards for three seconds and then stop both motors.&lt;br /&gt;
&lt;br /&gt;
So, here is the final result:&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;object class="BLOGGER-youtube-video" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="https://ytimg.googleusercontent.com/vi/F_TNtE2B6Lg/0.jpg" height="266" width="320"&gt;&lt;param name="movie" value="https://www.youtube.com/v/F_TNtE2B6Lg?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" /&gt;&lt;param name="bgcolor" value="#FFFFFF" /&gt;&lt;param name="allowFullScreen" value="true" /&gt;&lt;embed width="320" height="266"  src="https://www.youtube.com/v/F_TNtE2B6Lg?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/div&gt;
&lt;br /&gt;
In the next article I will use the DifferentialPilot-class, which is the superior level of abstraction for controlling the motors, to move a two-wheeled robot which can drive turns for example.&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-01-11&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Lego Mindstorms EV3 Components: Infrared Sensor - Part 1</title>
        <category label="0.5.0"/>
        <category label="components"/>
        <category label="EV3"/>
        <category label="infrared"/>
        <category label="Lego"/>
        <category label="lejos"/>
        <category label="Mindstorms"/>
        <category label="sensor"/>
        <published>2014-01-27T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/01/27/lego-mindstorms-ev3-components--infrar.html" rel="tag"&gt;Lego Mindstorms EV3 Components: Infrared Sensor - Part 1&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-01-27"&gt;2014-01-27&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;Now that we have demonstrated how to work with motors, the next component we will focus on is a sensor - the infrared sensor.&lt;br /&gt;
&lt;br /&gt;
In this first part we will show how to use the ability of the sensor to find objects and recognize the distance between that object and the sensor. There are other functionalities like receiving commands from the infrared remote control, which we will focus on in later posts.&lt;br /&gt;
&lt;br /&gt;
The used lejos version is 0.5.0-alpha like in our last postings as it is still the most current version (01/27/2014).&lt;br /&gt;
&lt;br /&gt;
&lt;h2&gt;
    The robot&lt;/h2&gt;
First, as always, we needed a new robot which uses the infrared sensor. Therefore I just enhanced the robot from the last episode a bit (so if you want to understand the source code in this posting it will help if you already have checked the two postings about &lt;a href="http://www.rapidpm.org/2014/01/lego-mindstorms-ev3-components-motors.html"&gt;using&lt;/a&gt; &lt;a href="http://www.rapidpm.org/2014/01/lego-mindstorms-ev3-components-motors_15.html"&gt;motors&lt;/a&gt;). I strengthened the basement between the two wheels, so that it wouldn't break because of the weight of the brick and other components. The brick is now no longer located directly between the wheels, but a bit more above. Additionally, I mounted the infrared sensor centered above / in front of the brick and plugged it into the sensor plug 2. The result looks like the following. &lt;br /&gt;
&lt;br /&gt;
&lt;a href="http://2.bp.blogspot.com/-opuibjzU9_I/UuJxa2QG1vI/AAAAAAAAALE/yMY5H4v2YBU/s1600/DSCN0625e.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-opuibjzU9_I/UuJxa2QG1vI/AAAAAAAAALE/yMY5H4v2YBU/s1600/DSCN0625e.jpg" height="320" width="292" /&gt;&lt;/a&gt;
&lt;a href="http://4.bp.blogspot.com/-RwYTQq7b_X0/UuJxZF2dN3I/AAAAAAAAAK8/G40LOi26B-U/s1600/DSCN0628e.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/-RwYTQq7b_X0/UuJxZF2dN3I/AAAAAAAAAK8/G40LOi26B-U/s1600/DSCN0628e.jpg" height="320" width="279" /&gt;&lt;/a&gt;
&lt;a href="http://1.bp.blogspot.com/-bMjGO2zIqPI/UuJxcCzoZvI/AAAAAAAAALM/ruR6MexJmBw/s1600/DSCN0629.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-bMjGO2zIqPI/UuJxcCzoZvI/AAAAAAAAALM/ruR6MexJmBw/s1600/DSCN0629.JPG" height="240" width="320" /&gt;&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
( could be a relative of disney's wall-e )&lt;br /&gt;
&lt;h2&gt;
    The parcours&lt;/h2&gt;
As said, in this tutorial we will focus on the ability of the infrared sensor to locate objects and return the objects' distance.&lt;br /&gt;
&lt;br /&gt;
The scenario I created for that purpose:&lt;br /&gt;
We have a walled zone (cage). The robot is placed anywhere in that cage and the robot will always move forwards until he is directly in front of a wall. He then will turn left (90°) and will again move forwards until he reaches the next wall.&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://4.bp.blogspot.com/--kzkAggDFmw/UuJzfiCnFJI/AAAAAAAAALU/DnGSbJe2vxY/s1600/DSCN0632.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/--kzkAggDFmw/UuJzfiCnFJI/AAAAAAAAALU/DnGSbJe2vxY/s1600/DSCN0632.JPG" height="249" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;h2&gt;
    The infrared sensor API&lt;/h2&gt;
So, before looking at the code let's talk a bit about what classes and methods the api offers for the infrared sensor.&lt;br /&gt;
&lt;br /&gt;
It's quite easy to use an infrared sensor. You can simply instantiate an object of the EV3InfraredSensor-class. The (slightly) harder part is to tell the program to use the functionality of the sensor to detect objects and return their distances - and react on the returned values of course. Therefore you need: RangeFinderAdaptor, RangeFeatureDetector and FeatureListener.&lt;br /&gt;
&lt;br /&gt;
But it's not as hard as it might seem now.&lt;br /&gt;
The aim is to have a listener on the sensor, so that the it returns the distance of a recognized object in regular time intervals (let's say: return the object's distance every second).&lt;br /&gt;
We need a class, which implements the FeatureListener, to do that. In my opinion the name FeatureListener is a bit confusing.. "Feature" means the object that has been detected by the sensor. The class which implements it has to implement the method&lt;br /&gt;
public void featureDetected(final Feature feature, final FeatureDetector detector);&lt;br /&gt;
And this method is called in the given interval, so we react to the distance of the detected object here (we will see how that works in the code for the parcours).&lt;br /&gt;
But that implementing class is the last thing we will do.&lt;br /&gt;
The regular order for realizing our aim with the instantiated Sensor-object is:&lt;br /&gt;
&lt;ol&gt;
    &lt;li&gt;Instantiate a RangeFinderAdaptor-object and tell it in which mode the sensor is used&lt;/li&gt;
    &lt;li&gt;Instantiate a RangeFeatureDetector-object and tell it: the interval of checking the object's distance and the maximum distance of objects. It also needs the (prior to this step) created RangeFinderAdaptor-object.&lt;/li&gt;
    &lt;li&gt;Instantiate an object of the class which implements the FeatureListener&lt;/li&gt;
    &lt;li&gt;Add the instantiated listener from step 3 to the RangeFeatureDetector-object from step 2.&lt;/li&gt;
&lt;/ol&gt;
That's it. So after the theory let's have a look at the finished plain code.&lt;br /&gt;
&lt;br /&gt;
&lt;h2&gt;
    The code &lt;/h2&gt;
We have two classes this time. The Main-Class (as always) and the class which implements the needed FeatureListener.&lt;br /&gt;
&lt;br /&gt;
Let's start with the Main-Class:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.hardware.Button;
import lejos.hardware.motor.Motor;
import lejos.hardware.port.SensorPort;
import lejos.hardware.sensor.EV3IRSensor;
import lejos.robotics.RangeFinderAdaptor;
import lejos.robotics.navigation.DifferentialPilot;
import lejos.robotics.objectdetection.FeatureListener;
import lejos.robotics.objectdetection.RangeFeatureDetector;
import lejos.utility.Delay;

public class Main {

    protected final static double NINETY_DEGREES = 90.0;
    protected final static double PILOT_SPEED = 50.0;
    protected final static int PILOT_ACCELERATION = 25;
    protected final static float MAX_DISTANCE = 100.0f;
    protected final static int INTERVAL = 500;
    protected final static double WHEEL_DIAMETER = 30.0f;
    protected final static double DISTANCE_BETWEEN_WHEELS = 170.0;

    public static void main(String[] args) {

        final DifferentialPilot pilot = new DifferentialPilot(WHEEL_DIAMETER, DISTANCE_BETWEEN_WHEELS, Motor.C, Motor.B);
        final EV3IRSensor infraredSensor = new EV3IRSensor(SensorPort.S2);

        configurePilot(pilot);
        configureInfraredSensor(infraredSensor, pilot);

        //wait for the sensor to be completely initialized and start the robot
        Delay.msDelay(5000);
        System.out.println("    Starting!");
        pilot.forward();
        Button.waitForAnyPress();
    }

    private static void configureInfraredSensor(final EV3IRSensor infraredSensor, final DifferentialPilot pilot) {
        final RangeFinderAdaptor rangeFinderAdaptor = new RangeFinderAdaptor(infraredSensor.getDistanceMode());
        final RangeFeatureDetector rangeFeatureDetector = new RangeFeatureDetector(rangeFinderAdaptor, MAX_DISTANCE, INTERVAL);
        final FeatureListener detectedObjectListener = new DetectedObjectListener(pilot);
        rangeFeatureDetector.addListener(detectedObjectListener);
    }

    private static void configurePilot(final DifferentialPilot pilot) {
        pilot.setAcceleration(PILOT_ACCELERATION);
        pilot.setRotateSpeed(PILOT_SPEED);
        pilot.setTravelSpeed(PILOT_SPEED);
    }
}
&lt;/pre&gt;
&lt;br /&gt;
The main-method is quite short and simple. In the first part we instantiate the pilot to control the wheels/motors and the infrared sensor. For more information on the pilot check the corresponding postings about using motors with the lejos api if you haven't done yet).&lt;br /&gt;
The EV3InfraredSensor-class only needs to know which plug it is plugged into to create a corresponding object.&lt;br /&gt;
&lt;br /&gt;
After creating our needed pilot and sensor we need to configure them. Have a look at the configureInfraredSensor-method. That's were we realize the things described in the last paragraph.&lt;br /&gt;
&lt;ol&gt;
    &lt;li&gt;We create a RangeFinderAdaptor-object by telling the constructor in which mode the sensor should work.&lt;/li&gt;
    &lt;li&gt;We create a RangeFeatureDetector and assign the RangeFinderAdaptor-object plus the maximum distance of objects and the interval where the sensor should check for objects.&lt;/li&gt;
    &lt;li&gt;We create a FeatureListener-object which needs the pilot because we will control the pilot in it. We will see the implementation of the listener next.&lt;/li&gt;
    &lt;li&gt;We assign the created listener to the RangeFeatureDetector so the featureDetected-method of the listener is called in the configured interval.&lt;/li&gt;
&lt;/ol&gt;
After configuring the sensor I set a delay of five seconds because the configuration needs some time. When I tried starting the pilot without a delay it came to weird reactions like the robot moving forwards and backwards some millimeters jerkily.&lt;br /&gt;
After the delay the robot will start moving forwards and the rest of the code is done in the listener, so let's have a look at it next. (Button.waitForAnyPress() is just used to let the program continue. Without that line the program would just end before the robot even started moving.)&lt;br /&gt;
&lt;br /&gt;
The Listener-class:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.robotics.navigation.DifferentialPilot;
import lejos.robotics.objectdetection.Feature;
import lejos.robotics.objectdetection.FeatureDetector;
import lejos.robotics.objectdetection.FeatureListener;
import static org.rapidpm.ev3.infrared.Main.*;

public class DetectedObjectListener implements FeatureListener {

    private DifferentialPilot pilot;

    public DetectedObjectListener(final DifferentialPilot pilot) {
        this.pilot = pilot;
    }

    @Override
    public void featureDetected(final Feature feature, final FeatureDetector detector) {
        int range = (int)feature.getRangeReading().getRange();
        if(range &amp;lt;= 10){
            if(range &amp;lt;=2){
                System.exit(0);
            }
            pilot.stop();
            pilot.rotate(NINETY_DEGREES);
            pilot.forward();
        }
    }
}
&lt;/pre&gt;
&lt;br /&gt;
We have a field for the pilot from the constructor which we will use in the featureDetected()-method which is called in the configured interval.&lt;br /&gt;
In that method we get the distance/range of a recognized object from the Feature-object (which represents the detected object).&lt;br /&gt;
If the range is greater than 10 (centimeters), nothing will happen. The robot will of course continue moving forward (remember that in the main-method we called pilot.forward() and told the program to wait for a button press to exit the program).&lt;br /&gt;
If the range is lower than 10, we know that the robot has reached a wall. So we tell the pilot to stop. After that we let the robot rotate by 90°. At last we tell the pilot to move forwards again. An exception to that behavior is the special case if the range is lower or equals 2 cm. If that is the case the program will exit. Why is that? Without that backdoor, the program would run until any button of the brick is pressed (remember the main-method). But instead of having to grab the robot and press a button we now can just hold any object directly in front of the infrared sensor and the program will exit.&lt;br /&gt;
&lt;h2&gt;
    The result&lt;/h2&gt;
At the end I added some console output to the featureDetected-method to have some feedback during the execution of the program.&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;    @Override
    public void featureDetected(final Feature feature, final FeatureDetector detector) {
        int range = (int)feature.getRangeReading().getRange();
        if(range &amp;lt;= 10){
            if(range &amp;lt;=3){
                System.out.println("Recognized signal directly on front of me: exiting!");
                System.exit(0);
            }
            System.out.print("Reached wall! Stopping...");
            pilot.stop();
            System.out.println("done!");
            System.out.print("Rotating 90 degrees...");
            pilot.rotate(NINETY_DEGREES);
            System.out.println("done!");
            pilot.forward();
        } else {
            System.out.println("range: "+range);
        }
    }
&lt;/pre&gt;
&lt;br /&gt;
And here is the result (watch on youtube for better quality):&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;object class="BLOGGER-youtube-video" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="https://ytimg.googleusercontent.com/vi/OzLn8FzbEto/0.jpg" height="266" width="320"&gt;&lt;param name="movie" value="https://www.youtube.com/v/OzLn8FzbEto?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" /&gt;&lt;param name="bgcolor" value="#FFFFFF" /&gt;&lt;param name="allowFullScreen" value="true" /&gt;&lt;embed width="320" height="266"  src="https://www.youtube.com/v/OzLn8FzbEto?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/div&gt;
&lt;br /&gt;&lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-01-27&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
    <entry>
        <title>Lego Mindstorms EV3 Components: Infrared Sensor - Part 2</title>
        <category label="0.5.0"/>
        <category label="components"/>
        <category label="EV3"/>
        <category label="infrared"/>
        <category label="Lego"/>
        <category label="lejos"/>
        <category label="Mindstorms"/>
        <category label="Mindsuite"/>
        <category label="remote control"/>
        <category label="sensor"/>
        <published>2014-02-10T00:00:00+01:00</published>
        <author>
            <name>Sven Ruppert</name>
        </author>
        <content type="html">&lt;article class="article clearfix"&gt;
							&lt;header class="article-header"&gt;
								&lt;h2 class="article-title"&gt;&lt;a href="/2014/02/10/lego-mindstorms-ev3-components--infrar.html" rel="tag"&gt;Lego Mindstorms EV3 Components: Infrared Sensor - Part 2&lt;/a&gt;&lt;/h2&gt;
								&lt;p&gt;&lt;time datetime="2014-02-10"&gt;2014-02-10&lt;/time&gt; &lt;a href="/team/sven-ruppert" rel="author"&gt;from Sven Ruppert&lt;/a&gt;&lt;/p&gt;
							&lt;/header&gt;
							&lt;div class="article-content clearfix"&gt;
								&lt;div class="post-thumb"&gt;
									&lt;img src="./site/content/post_thumb.jpg" width="" height="" alt="" /&gt;
								&lt;/div&gt;
								&lt;div class="post-excerpt"&gt;In this second part on the mindstorm's infrared sensor we will focus on the remote control and the ability of the remote sensor to recognize commands from that remote control respectively. There are multiple buttons on that remote control and we will control the robot by pressing different buttons.&lt;br /&gt;
&lt;br /&gt;
&lt;h2&gt;
    The robot&lt;/h2&gt;
We will use the robot from the first part as it already uses the infrared sensor. The mindstorm's remote control looks like the following:&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://4.bp.blogspot.com/--ykPdzdmwGY/Uvd2Sls9PTI/AAAAAAAAAL8/l5i7epxq6rA/s1600/DSCN06462.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://4.bp.blogspot.com/--ykPdzdmwGY/Uvd2Sls9PTI/AAAAAAAAAL8/l5i7epxq6rA/s1600/DSCN06462.jpg" height="320" width="240" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
There are two buttons on the left (red) and two buttons on the right (blue). There is a fifth button at the top center which is (in contrast to all other buttons) a toggling button. So if you press it one time, the remote control sends a signal continuously until the button is pressed a second time. Before taking the photo I pressed that button one time to activate the green signal led. We will use that toggle button on the next part of the infrared sensor articles.&lt;br /&gt;
The red slider at the bottom center is for selecting a frequency channel. You can select four channels and the current channel is shown in the red circle under the toggling button.&lt;br /&gt;
&lt;h2&gt;
    The parcours&lt;/h2&gt;
There is the robot and there is the remote control. The aim is to press different buttons on the remote control to control and move the robot. We will use the two buttons on the left to let the robot rotate left/right, respectively the two buttons on the right to let the robot move forwards/backwards. When more than one button is pressed, the program should exit.&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;a href="http://3.bp.blogspot.com/-2hiF0vwZ5s0/Uvd2J57BhCI/AAAAAAAAAL0/nvAubN0xv3c/s1600/parcours.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-2hiF0vwZ5s0/Uvd2J57BhCI/AAAAAAAAAL0/nvAubN0xv3c/s1600/parcours.jpg" height="240" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;h2&gt;
    The infrared sensor API&lt;/h2&gt;
There are two relevant modes for the infrared sensor. The distance mode and the seek mode. We used the former implicitly in the last article and we will use it in this one because it offers the possibility to receive commands from the infrared remote control. The latter can be used to receive the position and the distance of the remote control to the robot (the next tutorial will use the seek mode).&lt;br /&gt;
&lt;br /&gt;
It's very easy to receive a command from the remote control. The only method we will use is infraredSensor.getRemoteCommand(0);&lt;br /&gt;
This will return an integer value which represents the pressed button on the remote control (e.g. the left upper button on the remote control will return 1). The parameter of the method is also an integer value which represents the frequency channel which we use on the remote control. You can select one of four different channels (via the red slider on the remote control). In this case we use channel 0 (which is called channel 1 on the remote control).&lt;br /&gt;
&lt;br /&gt;
That's it. We don't need RangeFinderAdaptors, RangeFeatureDetectors or anything like that this time. So let's directly jump to the finished code and see how it works.&lt;br /&gt;
&lt;h2&gt;
    The code &lt;/h2&gt;
There are two classes. The Main-class and an InfraredSignalCheckerThread, which extends Thread and contains the logic for received commands from the remote control.&lt;br /&gt;
&lt;br /&gt;
Let's start with the Main-Class:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.hardware.Button;
import lejos.hardware.motor.Motor;
import lejos.hardware.port.SensorPort;
import lejos.hardware.sensor.EV3IRSensor;
import lejos.robotics.navigation.DifferentialPilot;

public class Main {

    protected final static double NINETY_DEGREES = 90.0;
    protected final static double PILOT_SPEED = 100.0;
    protected final static int PILOT_ACCELERATION = 500;
    protected final static double WHEEL_DIAMETER = 30.0f;
    protected final static double DISTANCE_BETWEEN_WHEELS = 170.0;

    public static void main(String[] args) throws InterruptedException {

        final DifferentialPilot pilot = new DifferentialPilot(WHEEL_DIAMETER, DISTANCE_BETWEEN_WHEELS, Motor.C, Motor.B);
        final EV3IRSensor infraredSensor = new EV3IRSensor(SensorPort.S2);
        final InfraredSignalCheckerThread checkerThread = new InfraredSignalCheckerThread(infraredSensor, pilot);

        configurePilot(pilot);
        checkerThread.start();
        Button.waitForAnyPress();
    }

    private static void configurePilot(final DifferentialPilot pilot) {
        pilot.setAcceleration(PILOT_ACCELERATION);
        pilot.setRotateSpeed(PILOT_SPEED);
        pilot.setTravelSpeed(PILOT_SPEED);
    }
}
&lt;/pre&gt;
&lt;br /&gt;
If you've (hopefully) read our &lt;a href="http://www.rapidpm.org/2014/01/lego-mindstorms-ev3-components-infrared.html"&gt;last article&lt;/a&gt; on the infrared sensor, you will recognize that the Main-class became a bit smaller this time. We don't have to configure anything on the infrared sensor.&lt;br /&gt;
First we create instances for the pilot and the infrared sensor again. The new thing is the InfraredSignalCheckerThread which extends Thread. This class contains all the logic for received commands. The logic is implemented in a Thread-extending class because we want to listen continuously for any received commands. The created instance of the InfraredSignalCheckerThread needs the infraredSensor-object of course and it needs the pilot (because we will control/move the robot corresponding to the pressed button on the remote control).&lt;br /&gt;
&lt;br /&gt;
After we created the instances we configure the pilot and start the checkerThread. That's it. Let's have a look at the InfraredSignalCheckerThread-class now.&lt;br /&gt;
&lt;br /&gt;
The InfraredSignalCheckerThread-class:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;import lejos.hardware.sensor.EV3IRSensor;
import lejos.robotics.navigation.DifferentialPilot;

public class InfraredSignalCheckerThread extends Thread {

    private EV3IRSensor infraredSensor;
    private DifferentialPilot pilot;

    public InfraredSignalCheckerThread(final EV3IRSensor infraredSensor, final DifferentialPilot pilot){
        this.infraredSensor = infraredSensor;
        this.pilot = pilot;
    }

    @Override
    public void run() {
        while(true){
            final int remoteCommand = infraredSensor.getRemoteCommand(0);
            switch (remoteCommand){
                case 0:
                    pilot.quickStop();
                    break;
                case 1:
                    pilot.rotateLeft();
                    break;
                case 2:
                    pilot.rotateRight();
                    break;
                case 3:
                    pilot.forward();
                    break;
                case 4:
                    pilot.backward();
                    break;
                default:
                    System.out.println("button combination pressed..exiting...");
                    System.exit(0);
            }
        }
    }
}
&lt;/pre&gt;
&lt;br /&gt;
Let's have a look at the run-method. As you can see we have an infinite loop. In that loop we get an integer command from the method infraredSensor.getRemoteCommand(0). The given parameter (0) means that the infrared sensor should listen at frequency channel 0 (remember the red slider on the remote control for selecting a channel).&lt;br /&gt;
So now the thread is checking for any commands on channel 0 continuously. As next we check which command was sent. The different buttons send different integer values. Here is the documentation from within the EV3IRSensor-class:&lt;br /&gt;
&lt;br /&gt;
&lt;pre class="brush: java"&gt;/** The button values are:
* 1 TOP-LEFT
* 2 BOTTOM-LEFT
* 3 TOP-RIGHT
* 4 BOTTOM-RIGHT
* 5 TOP-LEFT + TOP-RIGHT
* 6 TOP-LEFT + BOTTOM-RIGHT
* 7 BOTTOM-LEFT + TOP-RIGHT
* 8 BOTTOM-LEFT + BOTTOM-RIGHT
* 9 CENTRE/BEACON
* 10 BOTTOM-LEFT + TOP-LEFT
* 11 TOP-RIGHT + BOTTOM-RIGHT
* (0 means no buttons pressed)
*/&lt;/pre&gt;
&lt;br /&gt;
So, as you can see if no button is pressed on the remote control the method will return 0. The four buttons we want to use return 1, 2, 3 and 4.&lt;br /&gt;
Knowing these return values the switch statement becomes very easy to understand. If no button is pressed the robot shouldn't move. If the top left button is pressed the robot should rotate to the left and so on, we just call the corresponding methods of the DifferentialPilot-class to control the motors. If more than one button is pressed at a time the program should exit.&lt;br /&gt;
&lt;h2&gt;
    The result&lt;/h2&gt;
And here is the result (watch on youtube for better quality):&lt;br /&gt;
&lt;br /&gt;
&lt;div class="separator" style="clear: both; text-align: center;"&gt;
    &lt;object class="BLOGGER-youtube-video" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="https://i1.ytimg.com/vi/Bco7R93tYv0/0.jpg" height="266" width="320"&gt;&lt;param name="movie" value="https://www.youtube.com/v/Bco7R93tYv0?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" /&gt;&lt;param name="bgcolor" value="#FFFFFF" /&gt;&lt;param name="allowFullScreen" value="true" /&gt;&lt;embed width="320" height="266"  src="https://www.youtube.com/v/Bco7R93tYv0?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
Some words on complications that I had while writing the program: After starting the CheckerThread I had to wait around 30 seconds before pressing a button on the remote control. I have no explaination for that but when I pressed any button earlier the robot moved very jerkily. I tried different workarounds like Thread.sleep() and Delay.ms() in the main-method and the checker-thread. I also tried a timer in the CheckerThread which printed a message on the console to tell the user that the program isn't yet ready if he tried to press any button during those first 30 seconds. But none of these attempts worked. &lt;/div&gt;
							&lt;/div&gt;
							&lt;footer class="article-footer clearfix"&gt;
								&lt;span class="post-author"&gt;&lt;a href="/team/sven-ruppert" rel="author"&gt;Sven Ruppert&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
								&lt;span class="post-date"&gt;&lt;a href="#" rel="date"&gt;2014-02-10&lt;/a&gt;&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;/span&gt;
							&lt;/footer&gt;
						&lt;/article&gt;</content>
        <summary>Das ist der Inhalt der in Kurzform angezeigt werden soll</summary>
    </entry>
</feed>
